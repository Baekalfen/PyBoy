<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pyboy.botsupport.tile API documentation</title>
<meta name="description" content="The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used both for
`pyboy.botsupport.sprite.Sprite` and â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy.botsupport.tile</code></h1>
</header>
<section id="section-intro">
<p>The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used both for
<a title="pyboy.botsupport.sprite.Sprite" href="sprite.html#pyboy.botsupport.sprite.Sprite"><code>Sprite</code></a> and <a title="pyboy.botsupport.tilemap.TileMap" href="tilemap.html#pyboy.botsupport.tilemap.TileMap"><code>TileMap</code></a>, when refering to graphics.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#
# License: See LICENSE file
# GitHub: https://github.com/Baekalfen/PyBoy
#

&#34;&#34;&#34;
The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used both for
`pyboy.botsupport.sprite.Sprite` and `pyboy.botsupport.tilemap.TileMap`, when refering to graphics.
&#34;&#34;&#34;

import numpy as np
from PIL import Image

from .constants import HIGH_TILEDATA, LOW_TILEDATA, VRAM_OFFSET


# TODO: Import from window_sdl2
def _getcolorcode(byte1, byte2, offset):
    &#34;&#34;&#34;Convert 2 bytes into color code at a given offset.

    The colors are 2 bit and are found like this:

    Color of the first pixel is 0b10
    | Color of the second pixel is 0b01
    v v
    1 0 0 1 0 0 0 1 &lt;- byte1
    0 1 1 1 1 1 0 0 &lt;- byte2
    &#34;&#34;&#34;
    return (((byte2 &gt;&gt; (offset)) &amp; 0b1) &lt;&lt; 1) + ((byte1 &gt;&gt; (offset)) &amp; 0b1)


class Tile:
    def __init__(self, mb, identifier=None, index=None):
        &#34;&#34;&#34;
        The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used for
        `pyboy.pyboy.PyBoy.get_tile`, `pyboy.botsupport.sprite.Sprite` and `pyboy.botsupport.tilemap.TileMap`, when
        refering to graphics.

        This class is not meant to be instantiated by developers reading this documentation, but it will be created
        internaly and returned by `pyboy.botsupport.sprite.Sprite.tiles` and
        `pyboy.botsupport.tilemap.TileMap.get_tile`.

        The data of this class is static, apart from the image data, which is loaded from the Game Boy&#39;s memory when
        needed. Be aware, that the graphics for the tile can change between each call to `pyboy.pyboy.PyBoy.tick`.
        &#34;&#34;&#34;

        self.mb = mb

        if index is not None:
            assert isinstance(index, tuple), &#34;Index parameters needs to be a tuple of (int:index, bool:signed)&#34;
            index, signed = index
            assert 0 &lt;= index &lt;= 0xFF, &#34;index out of range&#34;
            assert isinstance(signed, bool), &#34;signed is not instance of bool&#34;
            self._signed_tile_data = signed
            self._index = index
            offset = HIGH_TILEDATA if signed else LOW_TILEDATA
            self._data_address = offset + (16*index) # _OFFSET + self._index * 2
        elif identifier is not None:
            assert 0 &lt;= identifier &lt;= 0xFF+0x80, &#34;Identifier out of range&#34;
            self._signed_tile_data = identifier &gt; 0xFF
            self._index = identifier
            if self._signed_tile_data:
                self._index -= 0xFF
            self._data_address = LOW_TILEDATA + (16*identifier)
        else:
            raise Exception(&#34;No identifier or index specified&#34;)

    def get_identifier(self):
        &#34;&#34;&#34;
        The Game Boy has a slightly complicated indexing system for tiles. Use this attribute instead to get a unified
        and easy way to compare and identify tiles. If you want to modify the state of the tilemap or tile data
        directly in the emulator, you&#39;ll need to look at `pyboy.botsupport.tile.Tile.get_index`.

        Returns:
            int: Unique identifier for the tile
        &#34;&#34;&#34;
        return (self._data_address - LOW_TILEDATA) // 16
    identifier = property(get_identifier)

    def get_data_address(self):
        &#34;&#34;&#34;
        The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
        corresponding to the tile index. It is advised to use `pyboy.botsupport.tile.Tile.image` or one of the other
        `image`-functions if you want to view the tile.

        You can read how the data is read in the
        [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

        Returns:
            int: address in VRAM where tile data starts
        &#34;&#34;&#34;
        return self._data_address
    data_address = property(get_data_address)

    def get_index(self):
        &#34;&#34;&#34;
        If you need to compare two tiles, consider using `pyboy.botsupport.tile.Tile.identifier` instead, or simply the
        equal operator: `tile1 == tile2`. The index returned here is mostly for use when interfacing directly with the
        Game Boy.

        Each tile of the Game Boy is referred to by an index. This function returns the tile index this object
        corresponds to. It also returns a bool which specify whether the index is signed (True) or not (False). Both
        the bool and the index are needed to correctly identify a tile.

        The signed indexes also uses another starting address than the unsigned indexes. Use the
        `pyboy.botsupport.tile.Tile.data_address` attribute if you want the address of the tile data.

        You can read how the indexes work in the
        [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

        Returns:
            tuple (bool, int): First value indicates if the index is signed. The second value is the index.
            Both are needed for comparison.
        &#34;&#34;&#34;
        return (self._signed_tile_data, self._index)
    index = property(get_index)

    def image(self):
        &#34;&#34;&#34;
        Use this function to get an easy-to-use `PIL.Image` object of the tile. The image is 8x8 pixels in RGBA colors.

        Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

        Returns:
            PIL.Image : Image of tile in 8x8 pixels and RGBA colors.
        &#34;&#34;&#34;
        return Image.frombytes(&#39;RGBA&#39;, (8, 8), bytes(self.image_data()))

    def image_ndarray(self):
        &#34;&#34;&#34;
        Use this function to get an easy-to-use `numpy.ndarray` object of the tile. The array has a shape of (8, 8, 4)
        and each value is of `numpy.uint8`. The values corresponds to and RGBA image of 8x8 pixels with each sub-color
        in a separate cell.

        Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

        Returns:
            numpy.ndarray : Array of shape (8, 8, 4) with data type of `numpy.uint8`.
        &#34;&#34;&#34;
        return np.asarray(self.image_data()).view(dtype=np.uint8).reshape(8, 8, 4)

    def image_data(self):
        &#34;&#34;&#34;
        Use this function to get the raw tile data. The data is a `memoryview` corresponding to 8x8 pixels in RGBA
        colors.

        Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

        Returns:
            memoryview : Image data of tile in 8x8 pixels and RGBA colors.
        &#34;&#34;&#34;
        data = np.zeros((8, 8), dtype=np.uint32)

        for k in range(0, 16, 2): # 2 bytes for each line
            byte1 = self.mb.lcd.VRAM[self._data_address + k - VRAM_OFFSET]
            byte2 = self.mb.lcd.VRAM[self._data_address + k + 1 - VRAM_OFFSET]

            for x in range(8):
                colorcode = _getcolorcode(byte1, byte2, 7-x)
                data[k//2][x] = self.mb.lcd.BGP.getcolor(colorcode)

        return data

    # def highlight(self):
    #     &#34;&#34;&#34;
    #     Not yet implemented. Will be used to highlight the tile when debug windows are enabled.
    #     &#34;&#34;&#34;
    #     pass

    def __eq__(self, other):
        return self.identifier == other.identifier

    def __str__(self):
        high_low = &#39;H&#39; if self._signed_tile_data else &#39;L&#39;
        return f&#34;Tile: {high_low}, {self.index}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.botsupport.tile.Tile"><code class="flex name class">
<span>class <span class="ident">Tile</span></span>
<span>(</span><span>mb, identifier=None, index=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used for
<a title="pyboy.pyboy.PyBoy.get_tile" href="../pyboy.html#pyboy.pyboy.PyBoy.get_tile"><code>PyBoy.get_tile()</code></a>, <a title="pyboy.botsupport.sprite.Sprite" href="sprite.html#pyboy.botsupport.sprite.Sprite"><code>Sprite</code></a> and <a title="pyboy.botsupport.tilemap.TileMap" href="tilemap.html#pyboy.botsupport.tilemap.TileMap"><code>TileMap</code></a>, when
refering to graphics.</p>
<p>This class is not meant to be instantiated by developers reading this documentation, but it will be created
internaly and returned by <a title="pyboy.botsupport.sprite.Sprite.tiles" href="sprite.html#pyboy.botsupport.sprite.Sprite.tiles"><code>Sprite.tiles</code></a> and
<a title="pyboy.botsupport.tilemap.TileMap.get_tile" href="tilemap.html#pyboy.botsupport.tilemap.TileMap.get_tile"><code>TileMap.get_tile()</code></a>.</p>
<p>The data of this class is static, apart from the image data, which is loaded from the Game Boy's memory when
needed. Be aware, that the graphics for the tile can change between each call to <a title="pyboy.pyboy.PyBoy.tick" href="../pyboy.html#pyboy.pyboy.PyBoy.tick"><code>PyBoy.tick()</code></a>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Tile:
    def __init__(self, mb, identifier=None, index=None):
        &#34;&#34;&#34;
        The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used for
        `pyboy.pyboy.PyBoy.get_tile`, `pyboy.botsupport.sprite.Sprite` and `pyboy.botsupport.tilemap.TileMap`, when
        refering to graphics.

        This class is not meant to be instantiated by developers reading this documentation, but it will be created
        internaly and returned by `pyboy.botsupport.sprite.Sprite.tiles` and
        `pyboy.botsupport.tilemap.TileMap.get_tile`.

        The data of this class is static, apart from the image data, which is loaded from the Game Boy&#39;s memory when
        needed. Be aware, that the graphics for the tile can change between each call to `pyboy.pyboy.PyBoy.tick`.
        &#34;&#34;&#34;

        self.mb = mb

        if index is not None:
            assert isinstance(index, tuple), &#34;Index parameters needs to be a tuple of (int:index, bool:signed)&#34;
            index, signed = index
            assert 0 &lt;= index &lt;= 0xFF, &#34;index out of range&#34;
            assert isinstance(signed, bool), &#34;signed is not instance of bool&#34;
            self._signed_tile_data = signed
            self._index = index
            offset = HIGH_TILEDATA if signed else LOW_TILEDATA
            self._data_address = offset + (16*index) # _OFFSET + self._index * 2
        elif identifier is not None:
            assert 0 &lt;= identifier &lt;= 0xFF+0x80, &#34;Identifier out of range&#34;
            self._signed_tile_data = identifier &gt; 0xFF
            self._index = identifier
            if self._signed_tile_data:
                self._index -= 0xFF
            self._data_address = LOW_TILEDATA + (16*identifier)
        else:
            raise Exception(&#34;No identifier or index specified&#34;)

    def get_identifier(self):
        &#34;&#34;&#34;
        The Game Boy has a slightly complicated indexing system for tiles. Use this attribute instead to get a unified
        and easy way to compare and identify tiles. If you want to modify the state of the tilemap or tile data
        directly in the emulator, you&#39;ll need to look at `pyboy.botsupport.tile.Tile.get_index`.

        Returns:
            int: Unique identifier for the tile
        &#34;&#34;&#34;
        return (self._data_address - LOW_TILEDATA) // 16
    identifier = property(get_identifier)

    def get_data_address(self):
        &#34;&#34;&#34;
        The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
        corresponding to the tile index. It is advised to use `pyboy.botsupport.tile.Tile.image` or one of the other
        `image`-functions if you want to view the tile.

        You can read how the data is read in the
        [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

        Returns:
            int: address in VRAM where tile data starts
        &#34;&#34;&#34;
        return self._data_address
    data_address = property(get_data_address)

    def get_index(self):
        &#34;&#34;&#34;
        If you need to compare two tiles, consider using `pyboy.botsupport.tile.Tile.identifier` instead, or simply the
        equal operator: `tile1 == tile2`. The index returned here is mostly for use when interfacing directly with the
        Game Boy.

        Each tile of the Game Boy is referred to by an index. This function returns the tile index this object
        corresponds to. It also returns a bool which specify whether the index is signed (True) or not (False). Both
        the bool and the index are needed to correctly identify a tile.

        The signed indexes also uses another starting address than the unsigned indexes. Use the
        `pyboy.botsupport.tile.Tile.data_address` attribute if you want the address of the tile data.

        You can read how the indexes work in the
        [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

        Returns:
            tuple (bool, int): First value indicates if the index is signed. The second value is the index.
            Both are needed for comparison.
        &#34;&#34;&#34;
        return (self._signed_tile_data, self._index)
    index = property(get_index)

    def image(self):
        &#34;&#34;&#34;
        Use this function to get an easy-to-use `PIL.Image` object of the tile. The image is 8x8 pixels in RGBA colors.

        Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

        Returns:
            PIL.Image : Image of tile in 8x8 pixels and RGBA colors.
        &#34;&#34;&#34;
        return Image.frombytes(&#39;RGBA&#39;, (8, 8), bytes(self.image_data()))

    def image_ndarray(self):
        &#34;&#34;&#34;
        Use this function to get an easy-to-use `numpy.ndarray` object of the tile. The array has a shape of (8, 8, 4)
        and each value is of `numpy.uint8`. The values corresponds to and RGBA image of 8x8 pixels with each sub-color
        in a separate cell.

        Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

        Returns:
            numpy.ndarray : Array of shape (8, 8, 4) with data type of `numpy.uint8`.
        &#34;&#34;&#34;
        return np.asarray(self.image_data()).view(dtype=np.uint8).reshape(8, 8, 4)

    def image_data(self):
        &#34;&#34;&#34;
        Use this function to get the raw tile data. The data is a `memoryview` corresponding to 8x8 pixels in RGBA
        colors.

        Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

        Returns:
            memoryview : Image data of tile in 8x8 pixels and RGBA colors.
        &#34;&#34;&#34;
        data = np.zeros((8, 8), dtype=np.uint32)

        for k in range(0, 16, 2): # 2 bytes for each line
            byte1 = self.mb.lcd.VRAM[self._data_address + k - VRAM_OFFSET]
            byte2 = self.mb.lcd.VRAM[self._data_address + k + 1 - VRAM_OFFSET]

            for x in range(8):
                colorcode = _getcolorcode(byte1, byte2, 7-x)
                data[k//2][x] = self.mb.lcd.BGP.getcolor(colorcode)

        return data

    # def highlight(self):
    #     &#34;&#34;&#34;
    #     Not yet implemented. Will be used to highlight the tile when debug windows are enabled.
    #     &#34;&#34;&#34;
    #     pass

    def __eq__(self, other):
        return self.identifier == other.identifier

    def __str__(self):
        high_low = &#39;H&#39; if self._signed_tile_data else &#39;L&#39;
        return f&#34;Tile: {high_low}, {self.index}&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyboy.botsupport.tile.Tile.data_address"><code class="name">var <span class="ident">data_address</span></code></dt>
<dd>
<section class="desc"><p>The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
corresponding to the tile index. It is advised to use <a title="pyboy.botsupport.tile.Tile.image" href="#pyboy.botsupport.tile.Tile.image"><code>Tile.image()</code></a> or one of the other
<code>image</code>-functions if you want to view the tile.</p>
<p>You can read how the data is read in the
<a href="http://bgb.bircd.org/pandocs.htm#vramtiledata">Pan Docs: VRAM Tile Data</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int</code></strong></dt>
<dd>address in VRAM where tile data starts</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_data_address(self):
    &#34;&#34;&#34;
    The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
    corresponding to the tile index. It is advised to use `pyboy.botsupport.tile.Tile.image` or one of the other
    `image`-functions if you want to view the tile.

    You can read how the data is read in the
    [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

    Returns:
        int: address in VRAM where tile data starts
    &#34;&#34;&#34;
    return self._data_address</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.tile.Tile.identifier"><code class="name">var <span class="ident">identifier</span></code></dt>
<dd>
<section class="desc"><p>The Game Boy has a slightly complicated indexing system for tiles. Use this attribute instead to get a unified
and easy way to compare and identify tiles. If you want to modify the state of the tilemap or tile data
directly in the emulator, you'll need to look at <a title="pyboy.botsupport.tile.Tile.get_index" href="#pyboy.botsupport.tile.Tile.get_index"><code>Tile.get_index()</code></a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int</code></strong></dt>
<dd>Unique identifier for the tile</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_identifier(self):
    &#34;&#34;&#34;
    The Game Boy has a slightly complicated indexing system for tiles. Use this attribute instead to get a unified
    and easy way to compare and identify tiles. If you want to modify the state of the tilemap or tile data
    directly in the emulator, you&#39;ll need to look at `pyboy.botsupport.tile.Tile.get_index`.

    Returns:
        int: Unique identifier for the tile
    &#34;&#34;&#34;
    return (self._data_address - LOW_TILEDATA) // 16</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.tile.Tile.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>If you need to compare two tiles, consider using <a title="pyboy.botsupport.tile.Tile.identifier" href="#pyboy.botsupport.tile.Tile.identifier"><code>Tile.identifier</code></a> instead, or simply the
equal operator: <code>tile1 == tile2</code>. The index returned here is mostly for use when interfacing directly with the
Game Boy.</p>
<p>Each tile of the Game Boy is referred to by an index. This function returns the tile index this object
corresponds to. It also returns a bool which specify whether the index is signed (True) or not (False). Both
the bool and the index are needed to correctly identify a tile.</p>
<p>The signed indexes also uses another starting address than the unsigned indexes. Use the
<a title="pyboy.botsupport.tile.Tile.data_address" href="#pyboy.botsupport.tile.Tile.data_address"><code>Tile.data_address</code></a> attribute if you want the address of the tile data.</p>
<p>You can read how the indexes work in the
<a href="http://bgb.bircd.org/pandocs.htm#vramtiledata">Pan Docs: VRAM Tile Data</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tuple</code></strong> :&ensp;<code>bool</code>, <code>int</code></dt>
<dd>First value indicates if the index is signed. The second value is the index.</dd>
</dl>
<p>Both are needed for comparison.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_index(self):
    &#34;&#34;&#34;
    If you need to compare two tiles, consider using `pyboy.botsupport.tile.Tile.identifier` instead, or simply the
    equal operator: `tile1 == tile2`. The index returned here is mostly for use when interfacing directly with the
    Game Boy.

    Each tile of the Game Boy is referred to by an index. This function returns the tile index this object
    corresponds to. It also returns a bool which specify whether the index is signed (True) or not (False). Both
    the bool and the index are needed to correctly identify a tile.

    The signed indexes also uses another starting address than the unsigned indexes. Use the
    `pyboy.botsupport.tile.Tile.data_address` attribute if you want the address of the tile data.

    You can read how the indexes work in the
    [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

    Returns:
        tuple (bool, int): First value indicates if the index is signed. The second value is the index.
        Both are needed for comparison.
    &#34;&#34;&#34;
    return (self._signed_tile_data, self._index)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyboy.botsupport.tile.Tile.get_data_address"><code class="name flex">
<span>def <span class="ident">get_data_address</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
corresponding to the tile index. It is advised to use <a title="pyboy.botsupport.tile.Tile.image" href="#pyboy.botsupport.tile.Tile.image"><code>Tile.image()</code></a> or one of the other
<code>image</code>-functions if you want to view the tile.</p>
<p>You can read how the data is read in the
<a href="http://bgb.bircd.org/pandocs.htm#vramtiledata">Pan Docs: VRAM Tile Data</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int</code></strong></dt>
<dd>address in VRAM where tile data starts</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_data_address(self):
    &#34;&#34;&#34;
    The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
    corresponding to the tile index. It is advised to use `pyboy.botsupport.tile.Tile.image` or one of the other
    `image`-functions if you want to view the tile.

    You can read how the data is read in the
    [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

    Returns:
        int: address in VRAM where tile data starts
    &#34;&#34;&#34;
    return self._data_address</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.tile.Tile.get_identifier"><code class="name flex">
<span>def <span class="ident">get_identifier</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy has a slightly complicated indexing system for tiles. Use this attribute instead to get a unified
and easy way to compare and identify tiles. If you want to modify the state of the tilemap or tile data
directly in the emulator, you'll need to look at <a title="pyboy.botsupport.tile.Tile.get_index" href="#pyboy.botsupport.tile.Tile.get_index"><code>Tile.get_index()</code></a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int</code></strong></dt>
<dd>Unique identifier for the tile</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_identifier(self):
    &#34;&#34;&#34;
    The Game Boy has a slightly complicated indexing system for tiles. Use this attribute instead to get a unified
    and easy way to compare and identify tiles. If you want to modify the state of the tilemap or tile data
    directly in the emulator, you&#39;ll need to look at `pyboy.botsupport.tile.Tile.get_index`.

    Returns:
        int: Unique identifier for the tile
    &#34;&#34;&#34;
    return (self._data_address - LOW_TILEDATA) // 16</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.tile.Tile.get_index"><code class="name flex">
<span>def <span class="ident">get_index</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>If you need to compare two tiles, consider using <a title="pyboy.botsupport.tile.Tile.identifier" href="#pyboy.botsupport.tile.Tile.identifier"><code>Tile.identifier</code></a> instead, or simply the
equal operator: <code>tile1 == tile2</code>. The index returned here is mostly for use when interfacing directly with the
Game Boy.</p>
<p>Each tile of the Game Boy is referred to by an index. This function returns the tile index this object
corresponds to. It also returns a bool which specify whether the index is signed (True) or not (False). Both
the bool and the index are needed to correctly identify a tile.</p>
<p>The signed indexes also uses another starting address than the unsigned indexes. Use the
<a title="pyboy.botsupport.tile.Tile.data_address" href="#pyboy.botsupport.tile.Tile.data_address"><code>Tile.data_address</code></a> attribute if you want the address of the tile data.</p>
<p>You can read how the indexes work in the
<a href="http://bgb.bircd.org/pandocs.htm#vramtiledata">Pan Docs: VRAM Tile Data</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tuple</code></strong> :&ensp;<code>bool</code>, <code>int</code></dt>
<dd>First value indicates if the index is signed. The second value is the index.</dd>
</dl>
<p>Both are needed for comparison.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_index(self):
    &#34;&#34;&#34;
    If you need to compare two tiles, consider using `pyboy.botsupport.tile.Tile.identifier` instead, or simply the
    equal operator: `tile1 == tile2`. The index returned here is mostly for use when interfacing directly with the
    Game Boy.

    Each tile of the Game Boy is referred to by an index. This function returns the tile index this object
    corresponds to. It also returns a bool which specify whether the index is signed (True) or not (False). Both
    the bool and the index are needed to correctly identify a tile.

    The signed indexes also uses another starting address than the unsigned indexes. Use the
    `pyboy.botsupport.tile.Tile.data_address` attribute if you want the address of the tile data.

    You can read how the indexes work in the
    [Pan Docs: VRAM Tile Data](http://bgb.bircd.org/pandocs.htm#vramtiledata).

    Returns:
        tuple (bool, int): First value indicates if the index is signed. The second value is the index.
        Both are needed for comparison.
    &#34;&#34;&#34;
    return (self._signed_tile_data, self._index)</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.tile.Tile.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this function to get an easy-to-use <code>PIL.Image</code> object of the tile. The image is 8x8 pixels in RGBA colors.</p>
<p>Be aware, that the graphics for this tile can change between each call to <a title="pyboy.pyboy.PyBoy.tick" href="../pyboy.html#pyboy.pyboy.PyBoy.tick"><code>PyBoy.tick()</code></a>.</p>
<h2 id="returns">Returns</h2>
<p>PIL.Image : Image of tile in 8x8 pixels and RGBA colors.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def image(self):
    &#34;&#34;&#34;
    Use this function to get an easy-to-use `PIL.Image` object of the tile. The image is 8x8 pixels in RGBA colors.

    Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

    Returns:
        PIL.Image : Image of tile in 8x8 pixels and RGBA colors.
    &#34;&#34;&#34;
    return Image.frombytes(&#39;RGBA&#39;, (8, 8), bytes(self.image_data()))</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.tile.Tile.image_data"><code class="name flex">
<span>def <span class="ident">image_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this function to get the raw tile data. The data is a <code>memoryview</code> corresponding to 8x8 pixels in RGBA
colors.</p>
<p>Be aware, that the graphics for this tile can change between each call to <a title="pyboy.pyboy.PyBoy.tick" href="../pyboy.html#pyboy.pyboy.PyBoy.tick"><code>PyBoy.tick()</code></a>.</p>
<h2 id="returns">Returns</h2>
<p>memoryview : Image data of tile in 8x8 pixels and RGBA colors.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def image_data(self):
    &#34;&#34;&#34;
    Use this function to get the raw tile data. The data is a `memoryview` corresponding to 8x8 pixels in RGBA
    colors.

    Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

    Returns:
        memoryview : Image data of tile in 8x8 pixels and RGBA colors.
    &#34;&#34;&#34;
    data = np.zeros((8, 8), dtype=np.uint32)

    for k in range(0, 16, 2): # 2 bytes for each line
        byte1 = self.mb.lcd.VRAM[self._data_address + k - VRAM_OFFSET]
        byte2 = self.mb.lcd.VRAM[self._data_address + k + 1 - VRAM_OFFSET]

        for x in range(8):
            colorcode = _getcolorcode(byte1, byte2, 7-x)
            data[k//2][x] = self.mb.lcd.BGP.getcolor(colorcode)

    return data</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.tile.Tile.image_ndarray"><code class="name flex">
<span>def <span class="ident">image_ndarray</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this function to get an easy-to-use <code>numpy.ndarray</code> object of the tile. The array has a shape of (8, 8, 4)
and each value is of <code>numpy.uint8</code>. The values corresponds to and RGBA image of 8x8 pixels with each sub-color
in a separate cell.</p>
<p>Be aware, that the graphics for this tile can change between each call to <a title="pyboy.pyboy.PyBoy.tick" href="../pyboy.html#pyboy.pyboy.PyBoy.tick"><code>PyBoy.tick()</code></a>.</p>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray : Array of shape (8, 8, 4) with data type of <code>numpy.uint8</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def image_ndarray(self):
    &#34;&#34;&#34;
    Use this function to get an easy-to-use `numpy.ndarray` object of the tile. The array has a shape of (8, 8, 4)
    and each value is of `numpy.uint8`. The values corresponds to and RGBA image of 8x8 pixels with each sub-color
    in a separate cell.

    Be aware, that the graphics for this tile can change between each call to `pyboy.pyboy.PyBoy.tick`.

    Returns:
        numpy.ndarray : Array of shape (8, 8, 4) with data type of `numpy.uint8`.
    &#34;&#34;&#34;
    return np.asarray(self.image_data()).view(dtype=np.uint8).reshape(8, 8, 4)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyboy.botsupport" href="index.html">pyboy.botsupport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.botsupport.tile.Tile" href="#pyboy.botsupport.tile.Tile">Tile</a></code></h4>
<ul class="two-column">
<li><code><a title="pyboy.botsupport.tile.Tile.data_address" href="#pyboy.botsupport.tile.Tile.data_address">data_address</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.get_data_address" href="#pyboy.botsupport.tile.Tile.get_data_address">get_data_address</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.get_identifier" href="#pyboy.botsupport.tile.Tile.get_identifier">get_identifier</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.get_index" href="#pyboy.botsupport.tile.Tile.get_index">get_index</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.identifier" href="#pyboy.botsupport.tile.Tile.identifier">identifier</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.image" href="#pyboy.botsupport.tile.Tile.image">image</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.image_data" href="#pyboy.botsupport.tile.Tile.image_data">image_data</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.image_ndarray" href="#pyboy.botsupport.tile.Tile.image_ndarray">image_ndarray</a></code></li>
<li><code><a title="pyboy.botsupport.tile.Tile.index" href="#pyboy.botsupport.tile.Tile.index">index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>