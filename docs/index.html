<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyboy API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:0.8em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# License: See LICENSE.md file
# GitHub: https://github.com/Baekalfen/PyBoy
#

__pdoc__ = {
    &#34;core&#34;: False,
    &#34;logging&#34;: False,
    &#34;pyboy&#34;: False,
    &#34;conftest&#34;: False,
}

__all__ = [&#34;PyBoy&#34;, &#34;PyBoyMemoryView&#34;]

from .pyboy import PyBoy, PyBoyMemoryView</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyboy.api" href="api/index.html">pyboy.api</a></code></dt>
<dd>
<section class="desc"><p>Tools to help interfacing with the Game Boy hardware</p></section>
</dd>
<dt><code class="name"><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code></dt>
<dd>
<section class="desc"><p>Plugins that extend PyBoy's functionality. The only publicly exposed, are the game wrappers.</p></section>
</dd>
<dt><code class="name"><a title="pyboy.utils" href="utils.html">pyboy.utils</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.PyBoy"><code class="flex name class">
<span>class <span class="ident">PyBoy</span></span>
<span>(</span><span>gamerom, *, window='SDL2', scale=3, symbols=None, bootrom=None, sound=False, sound_emulated=False, cgb=None, log_level='ERROR', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>PyBoy is loadable as an object in Python. This means, it can be initialized from another script, and be
controlled and probed by the script. It is supported to spawn multiple emulators, just instantiate the class
multiple times.</p>
<p>A range of methods are exposed, which should allow for complete control of the emulator. Please open an issue on
GitHub, if other methods are needed for your projects. Take a look at the files in <code>examples/</code> for a crude
"bots", which interact with the game.</p>
<p>Only the <code>gamerom</code> argument is required.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy = PyBoy('game_rom.gb')
&gt;&gt;&gt; for _ in range(60): # Use 'while True:' for infinite
...     pyboy.tick()
True...
&gt;&gt;&gt; pyboy.stop()

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gamerom</code></strong> :&ensp;<code>str</code></dt>
<dd>Filepath to a game-ROM for Game Boy or Game Boy Color.</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<ul>
<li>window (str): "SDL2", "OpenGL", or "null"</li>
<li>scale (int): Window scale factor. Doesn't apply to API.</li>
<li>symbols (str): Filepath to a .sym file to use. If unsure, specify <code>None</code>.</li>
<li>bootrom (str): Filepath to a boot-ROM to use. If unsure, specify <code>None</code>.</li>
<li>sound (bool): Enable sound emulation and output.</li>
<li>sound_emulated (bool): Enable sound emulation without any output. Used for compatibility.</li>
<li>cgb (bool): Forcing Game Boy Color mode.</li>
<li>log_level (str): "CRITICAL", "ERROR", "WARNING", "INFO" or "DEBUG"</li>
<li>color_palette (tuple): Specify the color palette to use for rendering.</li>
<li>cgb_color_palette (list of tuple): Specify the color palette to use for rendering in CGB-mode for non-color games.</li>
</ul>
<p>Other keyword arguments may exist for plugins that are not listed here. They can be viewed by running <code>pyboy --help</code> in the terminal.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyBoy:
    def __init__(
        self,
        gamerom,
        *,
        window=defaults[&#34;window&#34;],
        scale=defaults[&#34;scale&#34;],
        symbols=None,
        bootrom=None,
        sound=False,
        sound_emulated=False,
        cgb=None,
        log_level=defaults[&#34;log_level&#34;],
        **kwargs
    ):
        &#34;&#34;&#34;
        PyBoy is loadable as an object in Python. This means, it can be initialized from another script, and be
        controlled and probed by the script. It is supported to spawn multiple emulators, just instantiate the class
        multiple times.

        A range of methods are exposed, which should allow for complete control of the emulator. Please open an issue on
        GitHub, if other methods are needed for your projects. Take a look at the files in `examples/` for a crude
        &#34;bots&#34;, which interact with the game.

        Only the `gamerom` argument is required.

        Example:
        ```python
        &gt;&gt;&gt; pyboy = PyBoy(&#39;game_rom.gb&#39;)
        &gt;&gt;&gt; for _ in range(60): # Use &#39;while True:&#39; for infinite
        ...     pyboy.tick()
        True...
        &gt;&gt;&gt; pyboy.stop()

        ```

        Args:
            gamerom (str): Filepath to a game-ROM for Game Boy or Game Boy Color.

        Kwargs:
            * window (str): &#34;SDL2&#34;, &#34;OpenGL&#34;, or &#34;null&#34;
            * scale (int): Window scale factor. Doesn&#39;t apply to API.
            * symbols (str): Filepath to a .sym file to use. If unsure, specify `None`.
            * bootrom (str): Filepath to a boot-ROM to use. If unsure, specify `None`.
            * sound (bool): Enable sound emulation and output.
            * sound_emulated (bool): Enable sound emulation without any output. Used for compatibility.
            * cgb (bool): Forcing Game Boy Color mode.
            * log_level (str): &#34;CRITICAL&#34;, &#34;ERROR&#34;, &#34;WARNING&#34;, &#34;INFO&#34; or &#34;DEBUG&#34;
            * color_palette (tuple): Specify the color palette to use for rendering.
            * cgb_color_palette (list of tuple): Specify the color palette to use for rendering in CGB-mode for non-color games.

        Other keyword arguments may exist for plugins that are not listed here. They can be viewed by running `pyboy --help` in the terminal.
        &#34;&#34;&#34;

        self.initialized = False

        if &#34;bootrom_file&#34; in kwargs:
            logger.error(
                &#34;Deprecated use of &#39;bootrom_file&#39;. Use &#39;bootrom&#39; keyword argument instead. https://github.com/Baekalfen/PyBoy/wiki/Migrating-from-v1.x.x-to-v2.0.0&#34;
            )
            bootrom = kwargs.pop(&#34;bootrom_file&#34;)

        if &#34;window_type&#34; in kwargs:
            logger.error(
                &#34;Deprecated use of &#39;window_type&#39;. Use &#39;window&#39; keyword argument instead. https://github.com/Baekalfen/PyBoy/wiki/Migrating-from-v1.x.x-to-v2.0.0&#34;
            )
            window = kwargs.pop(&#34;window_type&#34;)

        if window not in [&#34;SDL2&#34;, &#34;OpenGL&#34;, &#34;null&#34;, &#34;headless&#34;, &#34;dummy&#34;]:
            raise KeyError(f&#39;Unknown window type: {window}. Use &#34;SDL2&#34;, &#34;OpenGL&#34;, or &#34;null&#34;&#39;)

        kwargs[&#34;window&#34;] = window
        kwargs[&#34;scale&#34;] = scale
        randomize = kwargs.pop(&#34;randomize&#34;, False) # Undocumented feature

        for k, v in defaults.items():
            if k not in kwargs:
                kwargs[k] = kwargs.get(k, defaults[k])

        _log_level(log_level)

        if gamerom is None:
            raise FileNotFoundError(f&#34;None is not a ROM file!&#34;)

        if not os.path.isfile(gamerom):
            raise FileNotFoundError(f&#34;ROM file {gamerom} was not found!&#34;)
        self.gamerom = gamerom

        self.rom_symbols = {}
        self.rom_symbols_inverse = {}
        if symbols is not None:
            if not os.path.isfile(symbols):
                raise FileNotFoundError(f&#34;Symbols file {symbols} was not found!&#34;)
        self.symbols_file = symbols
        self._load_symbols()

        self.mb = Motherboard(
            gamerom,
            bootrom,
            kwargs[&#34;color_palette&#34;],
            kwargs[&#34;cgb_color_palette&#34;],
            sound,
            sound_emulated,
            cgb,
            randomize=randomize,
        )

        # Validate all kwargs
        plugin_manager_keywords = []
        for x in parser_arguments():
            if not x:
                continue
            plugin_manager_keywords.extend(z.strip(&#34;-&#34;).replace(&#34;-&#34;, &#34;_&#34;) for y in x for z in y[:-1])

        for k, v in kwargs.items():
            if k not in defaults and k not in plugin_manager_keywords:
                logger.error(&#34;Unknown keyword argument: %s&#34;, k)
                raise KeyError(f&#34;Unknown keyword argument: {k}&#34;)

        # Performance measures
        self.avg_pre = 0
        self.avg_tick = 0
        self.avg_post = 0

        # Absolute frame count of the emulation
        self.frame_count = 0

        self.set_emulation_speed(1)
        self.paused = False
        self.events = []
        self.queued_input = []
        self.quitting = False
        self.stopped = False
        self.window_title = &#34;PyBoy&#34;

        ###################
        # API attributes
        self.screen = Screen(self.mb)
        &#34;&#34;&#34;
        Use this method to get a `pyboy.api.screen.Screen` object. This can be used to get the screen buffer in
        a variety of formats.

        It&#39;s also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
        `pyboy.api.screen.Screen.tilemap_position_list` for more information.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.screen.image.show()
        &gt;&gt;&gt; pyboy.screen.ndarray.shape
        (144, 160, 4)
        &gt;&gt;&gt; pyboy.screen.raw_buffer_format
        &#39;RGBA&#39;

        ```

        Returns
        -------
        `pyboy.api.screen.Screen`:
            A Screen object with helper functions for reading the screen buffer.
        &#34;&#34;&#34;
        self.memory = PyBoyMemoryView(self.mb)
        &#34;&#34;&#34;
        Provides a `pyboy.PyBoyMemoryView` object for reading and writing the memory space of the Game Boy.

        For a more comprehensive description, see the `pyboy.PyBoyMemoryView` class.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.memory[0x0000:0x0010] # Read 16 bytes from ROM bank 0
        [49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
        &gt;&gt;&gt; pyboy.memory[1, 0x2000] = 12 # Override address 0x2000 from ROM bank 1 with the value 12
        &gt;&gt;&gt; pyboy.memory[0xC000] = 1 # Write to address 0xC000 with value 1
        ```

        &#34;&#34;&#34;

        self.memory_scanner = MemoryScanner(self)
        &#34;&#34;&#34;
        Provides a `pyboy.api.memory_scanner.MemoryScanner` object for locating addresses of interest in the memory space
        of the Game Boy. This might require some trial and error. Values can be represented in memory in surprising ways.

        _Open an issue on GitHub if you need finer control, and we will take a look at it._

        Example:
        ```python
        &gt;&gt;&gt; current_score = 4 # You write current score in game
        &gt;&gt;&gt; pyboy.memory_scanner.scan_memory(current_score, start_addr=0xC000, end_addr=0xDFFF)
        []
        &gt;&gt;&gt; for _ in range(175):
        ...     pyboy.tick(1, True) # Progress the game to change score
        True...
        &gt;&gt;&gt; current_score = 8 # You write the new score in game
        &gt;&gt;&gt; from pyboy.api.memory_scanner import DynamicComparisonType
        &gt;&gt;&gt; addresses = pyboy.memory_scanner.rescan_memory(current_score, DynamicComparisonType.MATCH)
        &gt;&gt;&gt; print(addresses) # If repeated enough, only one address will remain
        []

        ```
        &#34;&#34;&#34;

        self.tilemap_background = TileMap(self, self.mb, &#34;BACKGROUND&#34;)
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _background_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](https://gbdev.io/pandocs/Tile_Maps.html).

        Example:
        ```
        &gt;&gt;&gt; pyboy.tilemap_background[8,8]
        1
        &gt;&gt;&gt; pyboy.tilemap_background[7:12,8]
        [0, 1, 0, 1, 0]
        &gt;&gt;&gt; pyboy.tilemap_background[7:12,8:11]
        [[0, 1, 0, 1, 0], [0, 2, 3, 4, 5], [0, 0, 6, 0, 0]]

        ```

        Returns
        -------
        `pyboy.api.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;

        self.tilemap_window = TileMap(self, self.mb, &#34;WINDOW&#34;)
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _window_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](https://gbdev.io/pandocs/Tile_Maps.html).

        Example:
        ```
        &gt;&gt;&gt; pyboy.tilemap_window[8,8]
        1
        &gt;&gt;&gt; pyboy.tilemap_window[7:12,8]
        [0, 1, 0, 1, 0]
        &gt;&gt;&gt; pyboy.tilemap_window[7:12,8:11]
        [[0, 1, 0, 1, 0], [0, 2, 3, 4, 5], [0, 0, 6, 0, 0]]

        ```

        Returns
        -------
        `pyboy.api.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;

        self.cartridge_title = self.mb.cartridge.gamename
        &#34;&#34;&#34;
        The title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
        have been truncated to 11 characters.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.cartridge_title # Title of PyBoy&#39;s default ROM
        &#39;DEFAULT-ROM&#39;

        ```

        Returns
        -------
        str :
            Game title
        &#34;&#34;&#34;

        self._hooks = {}

        self._plugin_manager = PluginManager(self, self.mb, kwargs)
        &#34;&#34;&#34;
        Returns
        -------
        `pyboy.plugins.manager.PluginManager`:
            Object for handling plugins in PyBoy
        &#34;&#34;&#34;

        self.game_wrapper = self._plugin_manager.gamewrapper()
        &#34;&#34;&#34;
        Provides an instance of a game-specific or generic wrapper. The game is detected by the cartridge&#39;s hard-coded
        game title (see `pyboy.PyBoy.cartridge_title`).

        If a game-specific wrapper is not found, a generic wrapper will be returned.

        To get more information, find the wrapper for your game in `pyboy.plugins`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.game_wrapper.start_game()
        &gt;&gt;&gt; pyboy.game_wrapper.reset_game()

        ```

        Returns
        -------
        `pyboy.plugins.base_plugin.PyBoyGameWrapper`:
            A game-specific wrapper object.
        &#34;&#34;&#34;

        self.initialized = True

    def _tick(self, render):
        if self.stopped:
            return False

        t_start = time.perf_counter_ns()
        self._handle_events(self.events)
        t_pre = time.perf_counter_ns()
        if not self.paused:
            self.__rendering(render)
            # Reenter mb.tick until we eventually get a clean exit without breakpoints
            while self.mb.tick():
                # Breakpoint reached
                # NOTE: Potentially reinject breakpoint that we have now stepped passed
                self.mb.breakpoint_reinject()

                # NOTE: PC has not been incremented when hitting breakpoint!
                breakpoint_meta = self.mb.breakpoint_reached()
                if breakpoint_meta != (-1, -1, -1):
                    bank, addr, _ = breakpoint_meta
                    self.mb.breakpoint_remove(bank, addr)
                    self.mb.breakpoint_singlestep_latch = 0

                    if not self._handle_hooks():
                        self._plugin_manager.handle_breakpoint()
                else:
                    if self.mb.breakpoint_singlestep_latch:
                        if not self._handle_hooks():
                            self._plugin_manager.handle_breakpoint()
                    # Keep singlestepping on, if that&#39;s what we&#39;re doing
                    self.mb.breakpoint_singlestep = self.mb.breakpoint_singlestep_latch

            self.frame_count += 1
        t_tick = time.perf_counter_ns()
        self._post_tick()
        t_post = time.perf_counter_ns()

        nsecs = t_pre - t_start
        self.avg_pre = 0.9 * self.avg_pre + (0.1*nsecs/1_000_000_000)

        nsecs = t_tick - t_pre
        self.avg_tick = 0.9 * self.avg_tick + (0.1*nsecs/1_000_000_000)

        nsecs = t_post - t_tick
        self.avg_post = 0.9 * self.avg_post + (0.1*nsecs/1_000_000_000)

        return not self.quitting

    def tick(self, count=1, render=True):
        &#34;&#34;&#34;
        Progresses the emulator ahead by `count` frame(s).

        To run the emulator in real-time, it will need to process 60 frames a second (for example in a while-loop).
        This function will block for roughly 16,67ms per frame, to not run faster than real-time, unless you specify
        otherwise with the `PyBoy.set_emulation_speed` method.

        If you need finer control than 1 frame, have a look at `PyBoy.hook_register` to inject code at a specific point
        in the game.

        Setting `render` to `True` will make PyBoy render the screen for *the last frame* of this tick. This can be seen
        as a type of &#34;frameskipping&#34; optimization.

        For AI training, it&#39;s adviced to use as high a count as practical, as it will otherwise reduce performance
        substantially. While setting `render` to `False`, you can still access the `PyBoy.game_area` to get a simpler
        representation of the game.

        If `render` was enabled, use `pyboy.api.screen.Screen` to get a NumPy buffer or raw memory buffer.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.tick() # Progress 1 frame with rendering
        True
        &gt;&gt;&gt; pyboy.tick(1) # Progress 1 frame with rendering
        True
        &gt;&gt;&gt; pyboy.tick(60, False) # Progress 60 frames *without* rendering
        True
        &gt;&gt;&gt; pyboy.tick(60, True) # Progress 60 frames and render *only the last frame*
        True
        &gt;&gt;&gt; for _ in range(60): # Progress 60 frames and render every frame
        ...     if not pyboy.tick(1, True):
        ...         break
        &gt;&gt;&gt;
        ```

        Args:
            count (int): Number of ticks to process
            render (bool): Whether to render an image for this tick
        Returns
        -------
        (True or False):
            False if emulation has ended otherwise True
        &#34;&#34;&#34;

        running = False
        while count != 0:
            _render = render and count == 1 # Only render on last tick to improve performance
            running = self._tick(_render)
            count -= 1
        return running

    def _handle_events(self, events):
        # This feeds events into the tick-loop from the window. There might already be events in the list from the API.
        events = self._plugin_manager.handle_events(events)
        for event in events:
            if event == WindowEvent.QUIT:
                self.quitting = True
            elif event == WindowEvent.RELEASE_SPEED_UP:
                # Switch between unlimited and 1x real-time emulation speed
                self.target_emulationspeed = int(bool(self.target_emulationspeed) ^ True)
                logger.debug(&#34;Speed limit: %d&#34;, self.target_emulationspeed)
            elif event == WindowEvent.STATE_SAVE:
                with open(self.gamerom + &#34;.state&#34;, &#34;wb&#34;) as f:
                    self.mb.save_state(IntIOWrapper(f))
            elif event == WindowEvent.STATE_LOAD:
                state_path = self.gamerom + &#34;.state&#34;
                if not os.path.isfile(state_path):
                    logger.error(&#34;State file not found: %s&#34;, state_path)
                    continue
                with open(state_path, &#34;rb&#34;) as f:
                    self.mb.load_state(IntIOWrapper(f))
            elif event == WindowEvent.PASS:
                pass # Used in place of None in Cython, when key isn&#39;t mapped to anything
            elif event == WindowEvent.PAUSE_TOGGLE:
                if self.paused:
                    self._unpause()
                else:
                    self._pause()
            elif event == WindowEvent.PAUSE:
                self._pause()
            elif event == WindowEvent.UNPAUSE:
                self._unpause()
            elif event == WindowEvent._INTERNAL_RENDERER_FLUSH:
                self._plugin_manager._post_tick_windows()
            else:
                self.mb.buttonevent(event)

    def _pause(self):
        if self.paused:
            return
        self.paused = True
        self.save_target_emulationspeed = self.target_emulationspeed
        self.target_emulationspeed = 1
        logger.info(&#34;Emulation paused!&#34;)
        self._update_window_title()

    def _unpause(self):
        if not self.paused:
            return
        self.paused = False
        self.target_emulationspeed = self.save_target_emulationspeed
        logger.info(&#34;Emulation unpaused!&#34;)
        self._update_window_title()

    def _post_tick(self):
        # Fix buggy PIL. They will copy our image buffer and destroy the
        # reference on some user operations like .save().
        if self.screen.image and not self.screen.image.readonly:
            self.screen._set_image()

        if self.frame_count % 60 == 0:
            self._update_window_title()
        self._plugin_manager.post_tick()
        self._plugin_manager.frame_limiter(self.target_emulationspeed)

        # Prepare an empty list, as the API might be used to send in events between ticks
        self.events = []
        while self.queued_input and self.frame_count == self.queued_input[0][0]:
            _, _event = heapq.heappop(self.queued_input)
            self.events.append(WindowEvent(_event))

    def _update_window_title(self):
        avg_emu = self.avg_pre + self.avg_tick + self.avg_post
        self.window_title = f&#34;CPU/frame: {(self.avg_pre + self.avg_tick) / SPF * 100:0.2f}%&#34;
        self.window_title += f&#39; Emulation: x{(round(SPF / avg_emu) if avg_emu &gt; 0 else &#34;INF&#34;)}&#39;
        if self.paused:
            self.window_title += &#34;[PAUSED]&#34;
        self.window_title += self._plugin_manager.window_title()
        self._plugin_manager._set_title()

    def __del__(self):
        self.stop(save=False)

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.stop()

    def stop(self, save=True):
        &#34;&#34;&#34;
        Gently stops the emulator and all sub-modules.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.stop() # Stop emulator and save game progress (cartridge RAM)
        &gt;&gt;&gt; pyboy.stop(False) # Stop emulator and discard game progress (cartridge RAM)

        ```

        Args:
            save (bool): Specify whether to save the game upon stopping. It will always be saved in a file next to the
                provided game-ROM.
        &#34;&#34;&#34;
        if self.initialized and not self.stopped:
            logger.info(&#34;###########################&#34;)
            logger.info(&#34;# Emulator is turning off #&#34;)
            logger.info(&#34;###########################&#34;)
            self._plugin_manager.stop()
            self.mb.stop(save)
            self.stopped = True

    ###################################################################
    # Scripts and bot methods
    #

    def button(self, input, delay=1):
        &#34;&#34;&#34;
        Send input to PyBoy in the form of &#34;a&#34;, &#34;b&#34;, &#34;start&#34;, &#34;select&#34;, &#34;left&#34;, &#34;right&#34;, &#34;up&#34; and &#34;down&#34;.

        The button will automatically be released at the following call to `PyBoy.tick`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.button(&#39;a&#39;) # Press button &#39;a&#39; and release after `pyboy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
        True
        &gt;&gt;&gt; pyboy.button(&#39;a&#39;, 3) # Press button &#39;a&#39; and release after 3 `pyboy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
        True
        ```

        Args:
            input (str): button to press
            delay (int, optional): Number of frames to delay the release. Defaults to 1
        &#34;&#34;&#34;
        input = input.lower()
        if input == &#34;left&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_LEFT)
            self.send_input(WindowEvent.RELEASE_ARROW_LEFT, delay)
        elif input == &#34;right&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
            self.send_input(WindowEvent.RELEASE_ARROW_RIGHT, delay)
        elif input == &#34;up&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_UP)
            self.send_input(WindowEvent.RELEASE_ARROW_UP, delay)
        elif input == &#34;down&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_DOWN)
            self.send_input(WindowEvent.RELEASE_ARROW_DOWN, delay)
        elif input == &#34;a&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_A)
            self.send_input(WindowEvent.RELEASE_BUTTON_A, delay)
        elif input == &#34;b&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_B)
            self.send_input(WindowEvent.RELEASE_BUTTON_B, delay)
        elif input == &#34;start&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_START)
            self.send_input(WindowEvent.RELEASE_BUTTON_START, delay)
        elif input == &#34;select&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
            self.send_input(WindowEvent.RELEASE_BUTTON_SELECT, delay)
        else:
            raise Exception(&#34;Unrecognized input:&#34;, input)

    def button_press(self, input):
        &#34;&#34;&#34;
        Send input to PyBoy in the form of &#34;a&#34;, &#34;b&#34;, &#34;start&#34;, &#34;select&#34;, &#34;left&#34;, &#34;right&#34;, &#34;up&#34; and &#34;down&#34;.

        The button will remain press until explicitly released with `PyBoy.button_release` or `PyBoy.send_input`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.button_press(&#39;a&#39;) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
        True
        &gt;&gt;&gt; pyboy.button_release(&#39;a&#39;) # Release button &#39;a&#39; on next call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
        True

        ```

        Args:
            input (str): button to press
        &#34;&#34;&#34;
        input = input.lower()

        if input == &#34;left&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_LEFT)
        elif input == &#34;right&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
        elif input == &#34;up&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_UP)
        elif input == &#34;down&#34;:
            self.send_input(WindowEvent.PRESS_ARROW_DOWN)
        elif input == &#34;a&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_A)
        elif input == &#34;b&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_B)
        elif input == &#34;start&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_START)
        elif input == &#34;select&#34;:
            self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
        else:
            raise Exception(&#34;Unrecognized input&#34;)

    def button_release(self, input):
        &#34;&#34;&#34;
        Send input to PyBoy in the form of &#34;a&#34;, &#34;b&#34;, &#34;start&#34;, &#34;select&#34;, &#34;left&#34;, &#34;right&#34;, &#34;up&#34; and &#34;down&#34;.

        This will release a button after a call to `PyBoy.button_press` or `PyBoy.send_input`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.button_press(&#39;a&#39;) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
        True
        &gt;&gt;&gt; pyboy.button_release(&#39;a&#39;) # Release button &#39;a&#39; on next call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
        True

        ```

        Args:
            input (str): button to release
        &#34;&#34;&#34;
        input = input.lower()
        if input == &#34;left&#34;:
            self.send_input(WindowEvent.RELEASE_ARROW_LEFT)
        elif input == &#34;right&#34;:
            self.send_input(WindowEvent.RELEASE_ARROW_RIGHT)
        elif input == &#34;up&#34;:
            self.send_input(WindowEvent.RELEASE_ARROW_UP)
        elif input == &#34;down&#34;:
            self.send_input(WindowEvent.RELEASE_ARROW_DOWN)
        elif input == &#34;a&#34;:
            self.send_input(WindowEvent.RELEASE_BUTTON_A)
        elif input == &#34;b&#34;:
            self.send_input(WindowEvent.RELEASE_BUTTON_B)
        elif input == &#34;start&#34;:
            self.send_input(WindowEvent.RELEASE_BUTTON_START)
        elif input == &#34;select&#34;:
            self.send_input(WindowEvent.RELEASE_BUTTON_SELECT)
        else:
            raise Exception(&#34;Unrecognized input&#34;)

    def send_input(self, event, delay=0):
        &#34;&#34;&#34;
        Send a single input to control the emulator. This is both Game Boy buttons and emulator controls. See
        `pyboy.utils.WindowEvent` for which events to send.

        Consider using `PyBoy.button` instead for easier access.

        Example:
        ```python
        &gt;&gt;&gt; from pyboy.utils import WindowEvent
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
        True
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A) # Release button &#39;a&#39; on next call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
        True
        ```

        And even simpler with delay:
        ```python
        &gt;&gt;&gt; from pyboy.utils import WindowEvent
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A, 2) # Release button &#39;a&#39; on third call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
        True
        ```

        Args:
            event (pyboy.WindowEvent): The event to send
            delay (int): 0 for immediately, number of frames to delay the input
        &#34;&#34;&#34;

        if delay:
            assert delay &gt; 0, &#34;Only positive integers allowed&#34;
            heapq.heappush(self.queued_input, (self.frame_count + delay, event))
        else:
            self.events.append(WindowEvent(event))

    def save_state(self, file_like_object):
        &#34;&#34;&#34;
        Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
        a game.

        You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
        case. Remember to `seek` the in-memory buffer to the beginning before calling `PyBoy.load_state`:

        ```python
        &gt;&gt;&gt; # Save to file
        &gt;&gt;&gt; with open(&#34;state_file.state&#34;, &#34;wb&#34;) as f:
        ...     pyboy.save_state(f)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Save to memory
        &gt;&gt;&gt; import io
        &gt;&gt;&gt; with io.BytesIO() as f:
        ...     f.seek(0)
        ...     pyboy.save_state(f)
        0

        ```

        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to write the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        if file_like_object.__class__.__name__ == &#34;TextIOWrapper&#34;:
            raise Exception(&#34;Text file not allowed. Did you specify open(..., &#39;wb&#39;)?&#34;)

        self.mb.save_state(IntIOWrapper(file_like_object))

    def load_state(self, file_like_object):
        &#34;&#34;&#34;
        Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
        in a game.

        You can either load it from a file, or from memory. See `PyBoy.save_state` for how to save the state, before you
        can load it here.

        To load a file, remember to load it as bytes:
        ```python
        &gt;&gt;&gt; # Load file
        &gt;&gt;&gt; with open(&#34;state_file.state&#34;, &#34;rb&#34;) as f:
        ...     pyboy.load_state(f)
        &gt;&gt;&gt;
        ```

        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to read the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        if file_like_object.__class__.__name__ == &#34;TextIOWrapper&#34;:
            raise Exception(&#34;Text file not allowed. Did you specify open(..., &#39;rb&#39;)?&#34;)

        self.mb.load_state(IntIOWrapper(file_like_object))

    def game_area_dimensions(self, x, y, width, height, follow_scrolling=True):
        &#34;&#34;&#34;
        If using the generic game wrapper (see `pyboy.PyBoy.game_wrapper`), you can use this to set the section of the
        tilemaps to extract. This will default to the entire tilemap.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.game_wrapper.shape
        (32, 32)
        &gt;&gt;&gt; pyboy.game_area_dimensions(2, 2, 10, 18, False)
        &gt;&gt;&gt; pyboy.game_wrapper.shape
        (10, 18)
        ```

        Args:
            x (int): Offset from top-left corner of the screen
            y (int): Offset from top-left corner of the screen
            width (int): Width of game area
            height (int): Height of game area
            follow_scrolling (bool): Whether to follow the scrolling of [SCX and SCY](https://gbdev.io/pandocs/Scrolling.html)
        &#34;&#34;&#34;
        self.game_wrapper._set_dimensions(x, y, width, height, follow_scrolling=True)

    def game_area_collision(self):
        &#34;&#34;&#34;
        Some game wrappers define a collision map. Check if your game wrapper has this feature implemented: `pyboy.plugins`.

        The output will be unique for each game wrapper.

        Example:
        ```python
        &gt;&gt;&gt; # This example show nothing, but a supported game will
        &gt;&gt;&gt; pyboy.game_area_collision()
        array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint32)

        ```

        Returns
        -------
        memoryview:
            Simplified 2-dimensional memoryview of the collision map
        &#34;&#34;&#34;
        return self.game_wrapper.game_area_collision()

    def game_area_mapping(self, mapping, sprite_offset=0):
        &#34;&#34;&#34;
        Define custom mappings for tile identifiers in the game area.

        Example of custom mapping:
        ```python
        &gt;&gt;&gt; mapping = [x for x in range(384)] # 1:1 mapping
        &gt;&gt;&gt; mapping[0] = 0 # Map tile identifier 0 -&gt; 0
        &gt;&gt;&gt; mapping[1] = 0 # Map tile identifier 1 -&gt; 0
        &gt;&gt;&gt; mapping[2] = 0 # Map tile identifier 2 -&gt; 0
        &gt;&gt;&gt; mapping[3] = 0 # Map tile identifier 3 -&gt; 0
        &gt;&gt;&gt; pyboy.game_area_mapping(mapping, 1000)

        ```

        Some game wrappers will supply mappings as well. See the specific documentation for your game wrapper:
        `pyboy.plugins`.
        ```python
        &gt;&gt;&gt; pyboy.game_area_mapping(pyboy.game_wrapper.mapping_one_to_one, 0)

        ```

        Args:
            mapping (list or ndarray): list of 384 (DMG) or 768 (CGB) tile mappings. Use `None` to reset to a 1:1 mapping.
            sprite_offest (int): Optional offset add to tile id for sprites
        &#34;&#34;&#34;

        if mapping is None:
            mapping = [x for x in range(768)]

        assert isinstance(sprite_offset, int)
        assert isinstance(mapping, (np.ndarray, list))
        assert len(mapping) == 384 or len(mapping) == 768

        self.game_wrapper.game_area_mapping(mapping, sprite_offset)

    def game_area(self):
        &#34;&#34;&#34;
        Use this method to get a matrix of the &#34;game area&#34; of the screen. This view is simplified to be perfect for
        machine learning applications.

        The layout will vary from game to game. Below is an example from Tetris:

        Example:
        ```python
        &gt;&gt;&gt; pyboy.game_area()
        array([[ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47, 130, 130,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47, 130, 130,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47]], dtype=uint32)

        ```

        If you want a &#34;compressed&#34;, &#34;minimal&#34; or raw mapping of tiles, you can change the mapping using
        `pyboy.PyBoy.game_area_mapping`. Either you&#39;ll have to supply your own mapping, or you can find one
        that is built-in with the game wrapper plugin for your game. See `pyboy.PyBoy.game_area_mapping`.

        Returns
        -------
        memoryview:
            Simplified 2-dimensional memoryview of the screen
        &#34;&#34;&#34;

        return self.game_wrapper.game_area()

    def _serial(self):
        &#34;&#34;&#34;
        Provides all data that has been sent over the serial port since last call to this function.

        Returns
        -------
        str :
            Buffer data
        &#34;&#34;&#34;
        return self.mb.getserial()

    def set_emulation_speed(self, target_speed):
        &#34;&#34;&#34;
        Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
        `target_speed`.

        The speed is defined as a multiple of real-time. I.e `target_speed=2` is double speed.

        A `target_speed` of `0` means unlimited. I.e. fastest possible execution.

        Some window types do not implement a frame-limiter, and will always run at full speed.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.tick() # Delays 16.67ms
        True
        &gt;&gt;&gt; pyboy.set_emulation_speed(0) # Disable limit
        &gt;&gt;&gt; pyboy.tick() # As fast as possible
        True
        ```

        Args:
            target_speed (int): Target emulation speed as multiplier of real-time.
        &#34;&#34;&#34;
        if self.initialized and self._plugin_manager.window_null_enabled:
            logger.warning(
                &#39;This window type does not support frame-limiting. `pyboy.set_emulation_speed(...)` will have no effect, as it\&#39;s always running at full speed.&#39;
            )

        if target_speed &gt; 5:
            logger.warning(&#34;The emulation speed might not be accurate when speed-target is higher than 5&#34;)
        self.target_emulationspeed = target_speed

    def __rendering(self, value):
        &#34;&#34;&#34;
        Disable or enable rendering
        &#34;&#34;&#34;
        self.mb.lcd.disable_renderer = not value

    def _is_cpu_stuck(self):
        return self.mb.cpu.is_stuck

    def _load_symbols(self):
        gamerom_file_no_ext, rom_ext = os.path.splitext(self.gamerom)
        for sym_path in [self.symbols_file, gamerom_file_no_ext + &#34;.sym&#34;, gamerom_file_no_ext + rom_ext + &#34;.sym&#34;]:
            if sym_path and os.path.isfile(sym_path):
                logger.info(&#34;Loading symbol file: %s&#34;, sym_path)
                with open(sym_path) as f:
                    for _line in f.readlines():
                        line = _line.strip()
                        if line == &#34;&#34;:
                            continue
                        elif line.startswith(&#34;;&#34;):
                            continue
                        elif line.startswith(&#34;[&#34;):
                            # Start of key group
                            # [labels]
                            # [definitions]
                            continue

                        try:
                            bank, addr, sym_label = re.split(&#34;:| &#34;, line.strip())
                            bank = int(bank, 16)
                            addr = int(addr, 16)
                            if not bank in self.rom_symbols:
                                self.rom_symbols[bank] = {}

                            if not addr in self.rom_symbols[bank]:
                                self.rom_symbols[bank][addr] = []

                            self.rom_symbols[bank][addr].append(sym_label)
                            self.rom_symbols_inverse[sym_label] = (bank, addr)
                        except ValueError as ex:
                            logger.warning(&#34;Skipping .sym line: %s&#34;, line.strip())
        return self.rom_symbols

    def _lookup_symbol(self, symbol):
        bank_addr = self.rom_symbols_inverse.get(symbol)
        if bank_addr is None:
            raise ValueError(&#34;Symbol not found: %s&#34; % symbol)
        return bank_addr

    def symbol_lookup(self, symbol):
        &#34;&#34;&#34;
        Look up a specific symbol from provided symbols file.

        This can be useful in combination with `PyBoy.memory` or even `PyBoy.hook_register`.

        See `PyBoy.hook_register` for how to load symbol into PyBoy.

        Example:
        ```python
        &gt;&gt;&gt; # Directly
        &gt;&gt;&gt; pyboy.memory[pyboy.symbol_lookup(&#34;Tileset&#34;)]
        0
        &gt;&gt;&gt; # By bank and address
        &gt;&gt;&gt; bank, addr = pyboy.symbol_lookup(&#34;Tileset&#34;)
        &gt;&gt;&gt; pyboy.memory[bank, addr]
        0
        &gt;&gt;&gt; pyboy.memory[bank, addr:addr+10]
        [0, 0, 0, 0, 0, 0, 102, 102, 102, 102]

        ```
        Returns
        -------
        (int, int):
            ROM/RAM bank, address
        &#34;&#34;&#34;
        return self._lookup_symbol(symbol)

    def hook_register(self, bank, addr, callback, context):
        &#34;&#34;&#34;
        Adds a hook into a specific bank and memory address.
        When the Game Boy executes this address, the provided callback function will be called.

        By providing an object as `context`, you can later get access to information inside and outside of the callback.

        Example:
        ```python
        &gt;&gt;&gt; context = &#34;Hello from hook&#34;
        &gt;&gt;&gt; def my_callback(context):
        ...     print(context)
        &gt;&gt;&gt; pyboy.hook_register(0, 0x100, my_callback, context)
        &gt;&gt;&gt; pyboy.tick(70)
        Hello from hook
        True

        ```

        If a symbol file is loaded, this function can also automatically resolve a bank and address from a symbol. To
        enable this, you&#39;ll need to place a `.sym` file next to your ROM, or provide it using:
        `PyBoy(..., symbols=&#34;game_rom.gb.sym&#34;)`.

        Then provide `None` for `bank` and the symbol for `addr` to trigger the automatic lookup.

        Example:
        ```python
        &gt;&gt;&gt; # Continued example above
        &gt;&gt;&gt; pyboy.hook_register(None, &#34;Main.move&#34;, lambda x: print(x), &#34;Hello from hook2&#34;)
        &gt;&gt;&gt; pyboy.tick(80)
        Hello from hook2
        True

        ```

        **NOTE**:

        Don&#39;t register hooks to something that isn&#39;t executable (graphics data etc.). This will cause your game to show
        weird behavior or crash. Hooks are installed by replacing the instruction at the bank and address with a special
        opcode (`0xDB`). If the address is read by the game instead of executed as code, this value will be read instead.

        Args:
            bank (int or None): ROM or RAM bank (None for symbol lookup)
            addr (int or str): Address in the Game Boy&#39;s address space (str for symbol lookup)
            callback (func): A function which takes `context` as argument
            context (object): Argument to pass to callback when hook is called
        &#34;&#34;&#34;
        if bank is None and isinstance(addr, str):
            bank, addr = self._lookup_symbol(addr)

        opcode = self.memory[bank, addr]
        if opcode == 0xDB:
            raise ValueError(&#34;Hook already registered for this bank and address.&#34;)
        self.mb.breakpoint_add(bank, addr)
        bank_addr_opcode = (bank &amp; 0xFF) &lt;&lt; 24 | (addr &amp; 0xFFFF) &lt;&lt; 8 | (opcode &amp; 0xFF)
        logger.debug(&#34;Adding hook for opcode %08x&#34;, bank_addr_opcode)
        self._hooks[bank_addr_opcode] = (callback, context)

    def hook_deregister(self, bank, addr):
        &#34;&#34;&#34;
        Remove a previously registered hook from a specific bank and memory address.

        Example:
        ```python
        &gt;&gt;&gt; context = &#34;Hello from hook&#34;
        &gt;&gt;&gt; def my_callback(context):
        ...     print(context)
        &gt;&gt;&gt; pyboy.hook_register(0, 0x2000, my_callback, context)
        &gt;&gt;&gt; pyboy.hook_deregister(0, 0x2000)

        ```

        This function can also deregister a hook based on a symbol. See `PyBoy.hook_register` for details.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.hook_register(None, &#34;Main&#34;, lambda x: print(x), &#34;Hello from hook&#34;)
        &gt;&gt;&gt; pyboy.hook_deregister(None, &#34;Main&#34;)

        ```

        Args:
            bank (int or None): ROM or RAM bank (None for symbol lookup)
            addr (int or str): Address in the Game Boy&#39;s address space (str for symbol lookup)
        &#34;&#34;&#34;
        if bank is None and isinstance(addr, str):
            bank, addr = self._lookup_symbol(addr)

        breakpoint_meta = self.mb.breakpoint_find(bank, addr)
        if not breakpoint_meta:
            raise ValueError(&#34;Breakpoint not found for bank and addr&#34;)
        _, _, opcode = breakpoint_meta

        self.mb.breakpoint_remove(bank, addr)
        bank_addr_opcode = (bank &amp; 0xFF) &lt;&lt; 24 | (addr &amp; 0xFFFF) &lt;&lt; 8 | (opcode &amp; 0xFF)
        self._hooks.pop(bank_addr_opcode)

    def _handle_hooks(self):
        if _handler := self._hooks.get(self.mb.breakpoint_waiting):
            (callback, context) = _handler
            callback(context)
            return True
        return False

    def get_sprite(self, sprite_index):
        &#34;&#34;&#34;
        Provides a `pyboy.api.sprite.Sprite` object, which makes the OAM data more presentable. The given index
        corresponds to index of the sprite in the &#34;Object Attribute Memory&#34; (OAM).

        The Game Boy supports 40 sprites in total. Read more details about it, in the [Pan
        Docs](http://bgb.bircd.org/pandocs.htm).

        ```python
        &gt;&gt;&gt; s = pyboy.get_sprite(12)
        &gt;&gt;&gt; s
        Sprite [12]: Position: (-8, -16), Shape: (8, 8), Tiles: (Tile: 0), On screen: False
        &gt;&gt;&gt; s.on_screen
        False
        &gt;&gt;&gt; s.tiles
        [Tile: 0]

        ```

        Args:
            index (int): Sprite index from 0 to 39.
        Returns
        -------
        `pyboy.api.sprite.Sprite`:
            Sprite corresponding to the given index.
        &#34;&#34;&#34;
        return Sprite(self.mb, sprite_index)

    def get_sprite_by_tile_identifier(self, tile_identifiers, on_screen=True):
        &#34;&#34;&#34;
        Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
        identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
        `pyboy.PyBoy.get_sprite` function to get a `pyboy.api.sprite.Sprite` object.

        Example:
        ```python
        &gt;&gt;&gt; print(pyboy.get_sprite_by_tile_identifier([43, 123]))
        [[0, 2, 4], []]

        ```

        Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2, and 4, while tile identifier
        `123` was not found anywhere.

        Args:
            identifiers (list): List of tile identifiers (int)
            on_screen (bool): Require that the matched sprite is on screen

        Returns
        -------
        list:
            list of sprite matches for every tile identifier in the input
        &#34;&#34;&#34;

        matches = []
        for i in tile_identifiers:
            match = []
            for s in range(constants.SPRITES):
                sprite = Sprite(self.mb, s)
                for t in sprite.tiles:
                    if t.tile_identifier == i and (not on_screen or (on_screen and sprite.on_screen)):
                        match.append(s)
            matches.append(match)
        return matches

    def get_tile(self, identifier):
        &#34;&#34;&#34;
        The Game Boy can have 384 tiles loaded in memory at once (768 for Game Boy Color). Use this method to get a
        `pyboy.api.tile.Tile`-object for given identifier.

        The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
        the `pyboy.api.tile.Tile` object for more information.

        Example:
        ```python
        &gt;&gt;&gt; t = pyboy.get_tile(2)
        &gt;&gt;&gt; t
        Tile: 2
        &gt;&gt;&gt; t.shape
        (8, 8)

        ```

        Returns
        -------
        `pyboy.api.tile.Tile`:
            A Tile object for the given identifier.
        &#34;&#34;&#34;
        return Tile(self.mb, identifier=identifier)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyboy.PyBoy.screen"><code class="name">var <span class="ident">screen</span></code></dt>
<dd>
<section class="desc"><p>Use this method to get a <code><a title="pyboy.api.screen.Screen" href="api/screen.html#pyboy.api.screen.Screen">Screen</a></code> object. This can be used to get the screen buffer in
a variety of formats.</p>
<p>It's also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
<code><a title="pyboy.api.screen.Screen.tilemap_position_list" href="api/screen.html#pyboy.api.screen.Screen.tilemap_position_list">Screen.tilemap_position_list</a></code> for more information.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.screen.image.show()
&gt;&gt;&gt; pyboy.screen.ndarray.shape
(144, 160, 4)
&gt;&gt;&gt; pyboy.screen.raw_buffer_format
'RGBA'

</code></pre>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.api.screen.Screen" href="api/screen.html#pyboy.api.screen.Screen">Screen</a></code>:
A Screen object with helper functions for reading the screen buffer.</p></section>
</dd>
<dt id="pyboy.PyBoy.memory"><code class="name">var <span class="ident">memory</span></code></dt>
<dd>
<section class="desc"><p>Provides a <code><a title="pyboy.PyBoyMemoryView" href="#pyboy.PyBoyMemoryView">PyBoyMemoryView</a></code> object for reading and writing the memory space of the Game Boy.</p>
<p>For a more comprehensive description, see the <code><a title="pyboy.PyBoyMemoryView" href="#pyboy.PyBoyMemoryView">PyBoyMemoryView</a></code> class.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.memory[0x0000:0x0010] # Read 16 bytes from ROM bank 0
[49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
&gt;&gt;&gt; pyboy.memory[1, 0x2000] = 12 # Override address 0x2000 from ROM bank 1 with the value 12
&gt;&gt;&gt; pyboy.memory[0xC000] = 1 # Write to address 0xC000 with value 1
</code></pre></section>
</dd>
<dt id="pyboy.PyBoy.memory_scanner"><code class="name">var <span class="ident">memory_scanner</span></code></dt>
<dd>
<section class="desc"><p>Provides a <code><a title="pyboy.api.memory_scanner.MemoryScanner" href="api/memory_scanner.html#pyboy.api.memory_scanner.MemoryScanner">MemoryScanner</a></code> object for locating addresses of interest in the memory space
of the Game Boy. This might require some trial and error. Values can be represented in memory in surprising ways.</p>
<p><em>Open an issue on GitHub if you need finer control, and we will take a look at it.</em></p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; current_score = 4 # You write current score in game
&gt;&gt;&gt; pyboy.memory_scanner.scan_memory(current_score, start_addr=0xC000, end_addr=0xDFFF)
[]
&gt;&gt;&gt; for _ in range(175):
...     pyboy.tick(1, True) # Progress the game to change score
True...
&gt;&gt;&gt; current_score = 8 # You write the new score in game
&gt;&gt;&gt; from pyboy.api.memory_scanner import DynamicComparisonType
&gt;&gt;&gt; addresses = pyboy.memory_scanner.rescan_memory(current_score, DynamicComparisonType.MATCH)
&gt;&gt;&gt; print(addresses) # If repeated enough, only one address will remain
[]

</code></pre></section>
</dd>
<dt id="pyboy.PyBoy.tilemap_background"><code class="name">var <span class="ident">tilemap_background</span></code></dt>
<dd>
<section class="desc"><p>The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
for the <em>background</em> tiles. The game chooses whether it wants to use the low or the high tilemap.</p>
<p>Read more details about it, in the <a href="https://gbdev.io/pandocs/Tile_Maps.html">Pan Docs</a>.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; pyboy.tilemap_background[8,8]
1
&gt;&gt;&gt; pyboy.tilemap_background[7:12,8]
[0, 1, 0, 1, 0]
&gt;&gt;&gt; pyboy.tilemap_background[7:12,8:11]
[[0, 1, 0, 1, 0], [0, 2, 3, 4, 5], [0, 0, 6, 0, 0]]

</code></pre>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.api.tilemap.TileMap" href="api/tilemap.html#pyboy.api.tilemap.TileMap">TileMap</a></code>:
A TileMap object for the tile map.</p></section>
</dd>
<dt id="pyboy.PyBoy.tilemap_window"><code class="name">var <span class="ident">tilemap_window</span></code></dt>
<dd>
<section class="desc"><p>The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
for the <em>window</em> tiles. The game chooses whether it wants to use the low or the high tilemap.</p>
<p>Read more details about it, in the <a href="https://gbdev.io/pandocs/Tile_Maps.html">Pan Docs</a>.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; pyboy.tilemap_window[8,8]
1
&gt;&gt;&gt; pyboy.tilemap_window[7:12,8]
[0, 1, 0, 1, 0]
&gt;&gt;&gt; pyboy.tilemap_window[7:12,8:11]
[[0, 1, 0, 1, 0], [0, 2, 3, 4, 5], [0, 0, 6, 0, 0]]

</code></pre>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.api.tilemap.TileMap" href="api/tilemap.html#pyboy.api.tilemap.TileMap">TileMap</a></code>:
A TileMap object for the tile map.</p></section>
</dd>
<dt id="pyboy.PyBoy.cartridge_title"><code class="name">var <span class="ident">cartridge_title</span></code></dt>
<dd>
<section class="desc"><p>The title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
have been truncated to 11 characters.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.cartridge_title # Title of PyBoy's default ROM
'DEFAULT-ROM'

</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str :</code></dt>
<dd>Game title</dd>
</dl></section>
</dd>
<dt id="pyboy.PyBoy.game_wrapper"><code class="name">var <span class="ident">game_wrapper</span></code></dt>
<dd>
<section class="desc"><p>Provides an instance of a game-specific or generic wrapper. The game is detected by the cartridge's hard-coded
game title (see <code><a title="pyboy.PyBoy.cartridge_title" href="#pyboy.PyBoy.cartridge_title">PyBoy.cartridge_title</a></code>).</p>
<p>If a game-specific wrapper is not found, a generic wrapper will be returned.</p>
<p>To get more information, find the wrapper for your game in <code><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.game_wrapper.start_game()
&gt;&gt;&gt; pyboy.game_wrapper.reset_game()

</code></pre>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.plugins.base_plugin.PyBoyGameWrapper" href="plugins/base_plugin.html#pyboy.plugins.base_plugin.PyBoyGameWrapper">PyBoyGameWrapper</a></code>:
A game-specific wrapper object.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyboy.PyBoy.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self, count=1, render=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Progresses the emulator ahead by <code>count</code> frame(s).</p>
<p>To run the emulator in real-time, it will need to process 60 frames a second (for example in a while-loop).
This function will block for roughly 16,67ms per frame, to not run faster than real-time, unless you specify
otherwise with the <code><a title="pyboy.PyBoy.set_emulation_speed" href="#pyboy.PyBoy.set_emulation_speed">PyBoy.set_emulation_speed()</a></code> method.</p>
<p>If you need finer control than 1 frame, have a look at <code><a title="pyboy.PyBoy.hook_register" href="#pyboy.PyBoy.hook_register">PyBoy.hook_register()</a></code> to inject code at a specific point
in the game.</p>
<p>Setting <code>render</code> to <code>True</code> will make PyBoy render the screen for <em>the last frame</em> of this tick. This can be seen
as a type of "frameskipping" optimization.</p>
<p>For AI training, it's adviced to use as high a count as practical, as it will otherwise reduce performance
substantially. While setting <code>render</code> to <code>False</code>, you can still access the <code><a title="pyboy.PyBoy.game_area" href="#pyboy.PyBoy.game_area">PyBoy.game_area()</a></code> to get a simpler
representation of the game.</p>
<p>If <code>render</code> was enabled, use <code><a title="pyboy.api.screen.Screen" href="api/screen.html#pyboy.api.screen.Screen">Screen</a></code> to get a NumPy buffer or raw memory buffer.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.tick() # Progress 1 frame with rendering
True
&gt;&gt;&gt; pyboy.tick(1) # Progress 1 frame with rendering
True
&gt;&gt;&gt; pyboy.tick(60, False) # Progress 60 frames *without* rendering
True
&gt;&gt;&gt; pyboy.tick(60, True) # Progress 60 frames and render *only the last frame*
True
&gt;&gt;&gt; for _ in range(60): # Progress 60 frames and render every frame
...     if not pyboy.tick(1, True):
...         break
&gt;&gt;&gt;
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of ticks to process</dd>
<dt><strong><code>render</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to render an image for this tick</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(True or False):
False if emulation has ended otherwise True</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self, count=1, render=True):
    &#34;&#34;&#34;
    Progresses the emulator ahead by `count` frame(s).

    To run the emulator in real-time, it will need to process 60 frames a second (for example in a while-loop).
    This function will block for roughly 16,67ms per frame, to not run faster than real-time, unless you specify
    otherwise with the `PyBoy.set_emulation_speed` method.

    If you need finer control than 1 frame, have a look at `PyBoy.hook_register` to inject code at a specific point
    in the game.

    Setting `render` to `True` will make PyBoy render the screen for *the last frame* of this tick. This can be seen
    as a type of &#34;frameskipping&#34; optimization.

    For AI training, it&#39;s adviced to use as high a count as practical, as it will otherwise reduce performance
    substantially. While setting `render` to `False`, you can still access the `PyBoy.game_area` to get a simpler
    representation of the game.

    If `render` was enabled, use `pyboy.api.screen.Screen` to get a NumPy buffer or raw memory buffer.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.tick() # Progress 1 frame with rendering
    True
    &gt;&gt;&gt; pyboy.tick(1) # Progress 1 frame with rendering
    True
    &gt;&gt;&gt; pyboy.tick(60, False) # Progress 60 frames *without* rendering
    True
    &gt;&gt;&gt; pyboy.tick(60, True) # Progress 60 frames and render *only the last frame*
    True
    &gt;&gt;&gt; for _ in range(60): # Progress 60 frames and render every frame
    ...     if not pyboy.tick(1, True):
    ...         break
    &gt;&gt;&gt;
    ```

    Args:
        count (int): Number of ticks to process
        render (bool): Whether to render an image for this tick
    Returns
    -------
    (True or False):
        False if emulation has ended otherwise True
    &#34;&#34;&#34;

    running = False
    while count != 0:
        _render = render and count == 1 # Only render on last tick to improve performance
        running = self._tick(_render)
        count -= 1
    return running</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, save=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Gently stops the emulator and all sub-modules.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.stop() # Stop emulator and save game progress (cartridge RAM)
&gt;&gt;&gt; pyboy.stop(False) # Stop emulator and discard game progress (cartridge RAM)

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code></dt>
<dd>Specify whether to save the game upon stopping. It will always be saved in a file next to the
provided game-ROM.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self, save=True):
    &#34;&#34;&#34;
    Gently stops the emulator and all sub-modules.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.stop() # Stop emulator and save game progress (cartridge RAM)
    &gt;&gt;&gt; pyboy.stop(False) # Stop emulator and discard game progress (cartridge RAM)

    ```

    Args:
        save (bool): Specify whether to save the game upon stopping. It will always be saved in a file next to the
            provided game-ROM.
    &#34;&#34;&#34;
    if self.initialized and not self.stopped:
        logger.info(&#34;###########################&#34;)
        logger.info(&#34;# Emulator is turning off #&#34;)
        logger.info(&#34;###########################&#34;)
        self._plugin_manager.stop()
        self.mb.stop(save)
        self.stopped = True</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.button"><code class="name flex">
<span>def <span class="ident">button</span></span>(<span>self, input, delay=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Send input to PyBoy in the form of "a", "b", "start", "select", "left", "right", "up" and "down".</p>
<p>The button will automatically be released at the following call to <code><a title="pyboy.PyBoy.tick" href="#pyboy.PyBoy.tick">PyBoy.tick()</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.button('a') # Press button 'a' and release after `pyboy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' released
True
&gt;&gt;&gt; pyboy.button('a', 3) # Press button 'a' and release after 3 `pyboy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' released
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>str</code></dt>
<dd>button to press</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of frames to delay the release. Defaults to 1</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button(self, input, delay=1):
    &#34;&#34;&#34;
    Send input to PyBoy in the form of &#34;a&#34;, &#34;b&#34;, &#34;start&#34;, &#34;select&#34;, &#34;left&#34;, &#34;right&#34;, &#34;up&#34; and &#34;down&#34;.

    The button will automatically be released at the following call to `PyBoy.tick`.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.button(&#39;a&#39;) # Press button &#39;a&#39; and release after `pyboy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
    True
    &gt;&gt;&gt; pyboy.button(&#39;a&#39;, 3) # Press button &#39;a&#39; and release after 3 `pyboy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
    True
    ```

    Args:
        input (str): button to press
        delay (int, optional): Number of frames to delay the release. Defaults to 1
    &#34;&#34;&#34;
    input = input.lower()
    if input == &#34;left&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_LEFT)
        self.send_input(WindowEvent.RELEASE_ARROW_LEFT, delay)
    elif input == &#34;right&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
        self.send_input(WindowEvent.RELEASE_ARROW_RIGHT, delay)
    elif input == &#34;up&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_UP)
        self.send_input(WindowEvent.RELEASE_ARROW_UP, delay)
    elif input == &#34;down&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_DOWN)
        self.send_input(WindowEvent.RELEASE_ARROW_DOWN, delay)
    elif input == &#34;a&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_A)
        self.send_input(WindowEvent.RELEASE_BUTTON_A, delay)
    elif input == &#34;b&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_B)
        self.send_input(WindowEvent.RELEASE_BUTTON_B, delay)
    elif input == &#34;start&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_START)
        self.send_input(WindowEvent.RELEASE_BUTTON_START, delay)
    elif input == &#34;select&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
        self.send_input(WindowEvent.RELEASE_BUTTON_SELECT, delay)
    else:
        raise Exception(&#34;Unrecognized input:&#34;, input)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.button_press"><code class="name flex">
<span>def <span class="ident">button_press</span></span>(<span>self, input)</span>
</code></dt>
<dd>
<section class="desc"><p>Send input to PyBoy in the form of "a", "b", "start", "select", "left", "right", "up" and "down".</p>
<p>The button will remain press until explicitly released with <code><a title="pyboy.PyBoy.button_release" href="#pyboy.PyBoy.button_release">PyBoy.button_release()</a></code> or <code><a title="pyboy.PyBoy.send_input" href="#pyboy.PyBoy.send_input">PyBoy.send_input()</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.button_press('a') # Press button 'a' and keep pressed after `PyBoy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
True
&gt;&gt;&gt; pyboy.button_release('a') # Release button 'a' on next call to `PyBoy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' released
True

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>str</code></dt>
<dd>button to press</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_press(self, input):
    &#34;&#34;&#34;
    Send input to PyBoy in the form of &#34;a&#34;, &#34;b&#34;, &#34;start&#34;, &#34;select&#34;, &#34;left&#34;, &#34;right&#34;, &#34;up&#34; and &#34;down&#34;.

    The button will remain press until explicitly released with `PyBoy.button_release` or `PyBoy.send_input`.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.button_press(&#39;a&#39;) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
    True
    &gt;&gt;&gt; pyboy.button_release(&#39;a&#39;) # Release button &#39;a&#39; on next call to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
    True

    ```

    Args:
        input (str): button to press
    &#34;&#34;&#34;
    input = input.lower()

    if input == &#34;left&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_LEFT)
    elif input == &#34;right&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
    elif input == &#34;up&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_UP)
    elif input == &#34;down&#34;:
        self.send_input(WindowEvent.PRESS_ARROW_DOWN)
    elif input == &#34;a&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_A)
    elif input == &#34;b&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_B)
    elif input == &#34;start&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_START)
    elif input == &#34;select&#34;:
        self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
    else:
        raise Exception(&#34;Unrecognized input&#34;)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.button_release"><code class="name flex">
<span>def <span class="ident">button_release</span></span>(<span>self, input)</span>
</code></dt>
<dd>
<section class="desc"><p>Send input to PyBoy in the form of "a", "b", "start", "select", "left", "right", "up" and "down".</p>
<p>This will release a button after a call to <code><a title="pyboy.PyBoy.button_press" href="#pyboy.PyBoy.button_press">PyBoy.button_press()</a></code> or <code><a title="pyboy.PyBoy.send_input" href="#pyboy.PyBoy.send_input">PyBoy.send_input()</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.button_press('a') # Press button 'a' and keep pressed after `PyBoy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
True
&gt;&gt;&gt; pyboy.button_release('a') # Release button 'a' on next call to `PyBoy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' released
True

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>str</code></dt>
<dd>button to release</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_release(self, input):
    &#34;&#34;&#34;
    Send input to PyBoy in the form of &#34;a&#34;, &#34;b&#34;, &#34;start&#34;, &#34;select&#34;, &#34;left&#34;, &#34;right&#34;, &#34;up&#34; and &#34;down&#34;.

    This will release a button after a call to `PyBoy.button_press` or `PyBoy.send_input`.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.button_press(&#39;a&#39;) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
    True
    &gt;&gt;&gt; pyboy.button_release(&#39;a&#39;) # Release button &#39;a&#39; on next call to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
    True

    ```

    Args:
        input (str): button to release
    &#34;&#34;&#34;
    input = input.lower()
    if input == &#34;left&#34;:
        self.send_input(WindowEvent.RELEASE_ARROW_LEFT)
    elif input == &#34;right&#34;:
        self.send_input(WindowEvent.RELEASE_ARROW_RIGHT)
    elif input == &#34;up&#34;:
        self.send_input(WindowEvent.RELEASE_ARROW_UP)
    elif input == &#34;down&#34;:
        self.send_input(WindowEvent.RELEASE_ARROW_DOWN)
    elif input == &#34;a&#34;:
        self.send_input(WindowEvent.RELEASE_BUTTON_A)
    elif input == &#34;b&#34;:
        self.send_input(WindowEvent.RELEASE_BUTTON_B)
    elif input == &#34;start&#34;:
        self.send_input(WindowEvent.RELEASE_BUTTON_START)
    elif input == &#34;select&#34;:
        self.send_input(WindowEvent.RELEASE_BUTTON_SELECT)
    else:
        raise Exception(&#34;Unrecognized input&#34;)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.send_input"><code class="name flex">
<span>def <span class="ident">send_input</span></span>(<span>self, event, delay=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a single input to control the emulator. This is both Game Boy buttons and emulator controls. See
<code><a title="pyboy.utils.WindowEvent" href="utils.html#pyboy.utils.WindowEvent">WindowEvent</a></code> for which events to send.</p>
<p>Consider using <code><a title="pyboy.PyBoy.button" href="#pyboy.PyBoy.button">PyBoy.button()</a></code> instead for easier access.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; from pyboy.utils import WindowEvent
&gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press button 'a' and keep pressed after `PyBoy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
True
&gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A) # Release button 'a' on next call to `PyBoy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' released
True
</code></pre>
<p>And even simpler with delay:</p>
<pre><code class="language-python">&gt;&gt;&gt; from pyboy.utils import WindowEvent
&gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press button 'a' and keep pressed after `PyBoy.tick()`
&gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A, 2) # Release button 'a' on third call to `PyBoy.tick()`
&gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
True
&gt;&gt;&gt; pyboy.tick() # Button 'a' released
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>pyboy.WindowEvent</code></dt>
<dd>The event to send</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code></dt>
<dd>0 for immediately, number of frames to delay the input</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_input(self, event, delay=0):
    &#34;&#34;&#34;
    Send a single input to control the emulator. This is both Game Boy buttons and emulator controls. See
    `pyboy.utils.WindowEvent` for which events to send.

    Consider using `PyBoy.button` instead for easier access.

    Example:
    ```python
    &gt;&gt;&gt; from pyboy.utils import WindowEvent
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
    True
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A) # Release button &#39;a&#39; on next call to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
    True
    ```

    And even simpler with delay:
    ```python
    &gt;&gt;&gt; from pyboy.utils import WindowEvent
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press button &#39;a&#39; and keep pressed after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A, 2) # Release button &#39;a&#39; on third call to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; still pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button &#39;a&#39; released
    True
    ```

    Args:
        event (pyboy.WindowEvent): The event to send
        delay (int): 0 for immediately, number of frames to delay the input
    &#34;&#34;&#34;

    if delay:
        assert delay &gt; 0, &#34;Only positive integers allowed&#34;
        heapq.heappush(self.queued_input, (self.frame_count + delay, event))
    else:
        self.events.append(WindowEvent(event))</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.save_state"><code class="name flex">
<span>def <span class="ident">save_state</span></span>(<span>self, file_like_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
a game.</p>
<p>You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
case. Remember to <code>seek</code> the in-memory buffer to the beginning before calling <code><a title="pyboy.PyBoy.load_state" href="#pyboy.PyBoy.load_state">PyBoy.load_state()</a></code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; # Save to file
&gt;&gt;&gt; with open(&quot;state_file.state&quot;, &quot;wb&quot;) as f:
...     pyboy.save_state(f)
&gt;&gt;&gt;
&gt;&gt;&gt; # Save to memory
&gt;&gt;&gt; import io
&gt;&gt;&gt; with io.BytesIO() as f:
...     f.seek(0)
...     pyboy.save_state(f)
0

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :&ensp;<code>io.BufferedIOBase</code></dt>
<dd>A file-like object for which to write the emulator state.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_state(self, file_like_object):
    &#34;&#34;&#34;
    Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
    a game.

    You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
    case. Remember to `seek` the in-memory buffer to the beginning before calling `PyBoy.load_state`:

    ```python
    &gt;&gt;&gt; # Save to file
    &gt;&gt;&gt; with open(&#34;state_file.state&#34;, &#34;wb&#34;) as f:
    ...     pyboy.save_state(f)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Save to memory
    &gt;&gt;&gt; import io
    &gt;&gt;&gt; with io.BytesIO() as f:
    ...     f.seek(0)
    ...     pyboy.save_state(f)
    0

    ```

    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which to write the emulator state.
    &#34;&#34;&#34;

    if isinstance(file_like_object, str):
        raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

    if file_like_object.__class__.__name__ == &#34;TextIOWrapper&#34;:
        raise Exception(&#34;Text file not allowed. Did you specify open(..., &#39;wb&#39;)?&#34;)

    self.mb.save_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.load_state"><code class="name flex">
<span>def <span class="ident">load_state</span></span>(<span>self, file_like_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
in a game.</p>
<p>You can either load it from a file, or from memory. See <code><a title="pyboy.PyBoy.save_state" href="#pyboy.PyBoy.save_state">PyBoy.save_state()</a></code> for how to save the state, before you
can load it here.</p>
<p>To load a file, remember to load it as bytes:</p>
<pre><code class="language-python">&gt;&gt;&gt; # Load file
&gt;&gt;&gt; with open(&quot;state_file.state&quot;, &quot;rb&quot;) as f:
...     pyboy.load_state(f)
&gt;&gt;&gt;
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :&ensp;<code>io.BufferedIOBase</code></dt>
<dd>A file-like object for which to read the emulator state.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_state(self, file_like_object):
    &#34;&#34;&#34;
    Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
    in a game.

    You can either load it from a file, or from memory. See `PyBoy.save_state` for how to save the state, before you
    can load it here.

    To load a file, remember to load it as bytes:
    ```python
    &gt;&gt;&gt; # Load file
    &gt;&gt;&gt; with open(&#34;state_file.state&#34;, &#34;rb&#34;) as f:
    ...     pyboy.load_state(f)
    &gt;&gt;&gt;
    ```

    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which to read the emulator state.
    &#34;&#34;&#34;

    if isinstance(file_like_object, str):
        raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

    if file_like_object.__class__.__name__ == &#34;TextIOWrapper&#34;:
        raise Exception(&#34;Text file not allowed. Did you specify open(..., &#39;rb&#39;)?&#34;)

    self.mb.load_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.game_area_dimensions"><code class="name flex">
<span>def <span class="ident">game_area_dimensions</span></span>(<span>self, x, y, width, height, follow_scrolling=True)</span>
</code></dt>
<dd>
<section class="desc"><p>If using the generic game wrapper (see <code><a title="pyboy.PyBoy.game_wrapper" href="#pyboy.PyBoy.game_wrapper">PyBoy.game_wrapper</a></code>), you can use this to set the section of the
tilemaps to extract. This will default to the entire tilemap.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.game_wrapper.shape
(32, 32)
&gt;&gt;&gt; pyboy.game_area_dimensions(2, 2, 10, 18, False)
&gt;&gt;&gt; pyboy.game_wrapper.shape
(10, 18)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Offset from top-left corner of the screen</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Offset from top-left corner of the screen</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of game area</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>Height of game area</dd>
<dt><strong><code>follow_scrolling</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to follow the scrolling of <a href="https://gbdev.io/pandocs/Scrolling.html">SCX and SCY</a></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def game_area_dimensions(self, x, y, width, height, follow_scrolling=True):
    &#34;&#34;&#34;
    If using the generic game wrapper (see `pyboy.PyBoy.game_wrapper`), you can use this to set the section of the
    tilemaps to extract. This will default to the entire tilemap.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.game_wrapper.shape
    (32, 32)
    &gt;&gt;&gt; pyboy.game_area_dimensions(2, 2, 10, 18, False)
    &gt;&gt;&gt; pyboy.game_wrapper.shape
    (10, 18)
    ```

    Args:
        x (int): Offset from top-left corner of the screen
        y (int): Offset from top-left corner of the screen
        width (int): Width of game area
        height (int): Height of game area
        follow_scrolling (bool): Whether to follow the scrolling of [SCX and SCY](https://gbdev.io/pandocs/Scrolling.html)
    &#34;&#34;&#34;
    self.game_wrapper._set_dimensions(x, y, width, height, follow_scrolling=True)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.game_area_collision"><code class="name flex">
<span>def <span class="ident">game_area_collision</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Some game wrappers define a collision map. Check if your game wrapper has this feature implemented: <code><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code>.</p>
<p>The output will be unique for each game wrapper.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; # This example show nothing, but a supported game will
&gt;&gt;&gt; pyboy.game_area_collision()
array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint32)

</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>memoryview:</code></dt>
<dd>Simplified 2-dimensional memoryview of the collision map</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def game_area_collision(self):
    &#34;&#34;&#34;
    Some game wrappers define a collision map. Check if your game wrapper has this feature implemented: `pyboy.plugins`.

    The output will be unique for each game wrapper.

    Example:
    ```python
    &gt;&gt;&gt; # This example show nothing, but a supported game will
    &gt;&gt;&gt; pyboy.game_area_collision()
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint32)

    ```

    Returns
    -------
    memoryview:
        Simplified 2-dimensional memoryview of the collision map
    &#34;&#34;&#34;
    return self.game_wrapper.game_area_collision()</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.game_area_mapping"><code class="name flex">
<span>def <span class="ident">game_area_mapping</span></span>(<span>self, mapping, sprite_offset=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Define custom mappings for tile identifiers in the game area.</p>
<p>Example of custom mapping:</p>
<pre><code class="language-python">&gt;&gt;&gt; mapping = [x for x in range(384)] # 1:1 mapping
&gt;&gt;&gt; mapping[0] = 0 # Map tile identifier 0 -&gt; 0
&gt;&gt;&gt; mapping[1] = 0 # Map tile identifier 1 -&gt; 0
&gt;&gt;&gt; mapping[2] = 0 # Map tile identifier 2 -&gt; 0
&gt;&gt;&gt; mapping[3] = 0 # Map tile identifier 3 -&gt; 0
&gt;&gt;&gt; pyboy.game_area_mapping(mapping, 1000)

</code></pre>
<p>Some game wrappers will supply mappings as well. See the specific documentation for your game wrapper:
<code><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.game_area_mapping(pyboy.game_wrapper.mapping_one_to_one, 0)

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong> :&ensp;<code>list</code> or <code>ndarray</code></dt>
<dd>list of 384 (DMG) or 768 (CGB) tile mappings. Use <code>None</code> to reset to a 1:1 mapping.</dd>
<dt><strong><code>sprite_offest</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional offset add to tile id for sprites</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def game_area_mapping(self, mapping, sprite_offset=0):
    &#34;&#34;&#34;
    Define custom mappings for tile identifiers in the game area.

    Example of custom mapping:
    ```python
    &gt;&gt;&gt; mapping = [x for x in range(384)] # 1:1 mapping
    &gt;&gt;&gt; mapping[0] = 0 # Map tile identifier 0 -&gt; 0
    &gt;&gt;&gt; mapping[1] = 0 # Map tile identifier 1 -&gt; 0
    &gt;&gt;&gt; mapping[2] = 0 # Map tile identifier 2 -&gt; 0
    &gt;&gt;&gt; mapping[3] = 0 # Map tile identifier 3 -&gt; 0
    &gt;&gt;&gt; pyboy.game_area_mapping(mapping, 1000)

    ```

    Some game wrappers will supply mappings as well. See the specific documentation for your game wrapper:
    `pyboy.plugins`.
    ```python
    &gt;&gt;&gt; pyboy.game_area_mapping(pyboy.game_wrapper.mapping_one_to_one, 0)

    ```

    Args:
        mapping (list or ndarray): list of 384 (DMG) or 768 (CGB) tile mappings. Use `None` to reset to a 1:1 mapping.
        sprite_offest (int): Optional offset add to tile id for sprites
    &#34;&#34;&#34;

    if mapping is None:
        mapping = [x for x in range(768)]

    assert isinstance(sprite_offset, int)
    assert isinstance(mapping, (np.ndarray, list))
    assert len(mapping) == 384 or len(mapping) == 768

    self.game_wrapper.game_area_mapping(mapping, sprite_offset)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.game_area"><code class="name flex">
<span>def <span class="ident">game_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this method to get a matrix of the "game area" of the screen. This view is simplified to be perfect for
machine learning applications.</p>
<p>The layout will vary from game to game. Below is an example from Tetris:</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.game_area()
array([[ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47, 130, 130,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47, 130, 130,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
       [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47]], dtype=uint32)

</code></pre>
<p>If you want a "compressed", "minimal" or raw mapping of tiles, you can change the mapping using
<code><a title="pyboy.PyBoy.game_area_mapping" href="#pyboy.PyBoy.game_area_mapping">PyBoy.game_area_mapping()</a></code>. Either you'll have to supply your own mapping, or you can find one
that is built-in with the game wrapper plugin for your game. See <code><a title="pyboy.PyBoy.game_area_mapping" href="#pyboy.PyBoy.game_area_mapping">PyBoy.game_area_mapping()</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>memoryview:</code></dt>
<dd>Simplified 2-dimensional memoryview of the screen</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def game_area(self):
    &#34;&#34;&#34;
    Use this method to get a matrix of the &#34;game area&#34; of the screen. This view is simplified to be perfect for
    machine learning applications.

    The layout will vary from game to game. Below is an example from Tetris:

    Example:
    ```python
    &gt;&gt;&gt; pyboy.game_area()
    array([[ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47, 130, 130,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47, 130, 130,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47]], dtype=uint32)

    ```

    If you want a &#34;compressed&#34;, &#34;minimal&#34; or raw mapping of tiles, you can change the mapping using
    `pyboy.PyBoy.game_area_mapping`. Either you&#39;ll have to supply your own mapping, or you can find one
    that is built-in with the game wrapper plugin for your game. See `pyboy.PyBoy.game_area_mapping`.

    Returns
    -------
    memoryview:
        Simplified 2-dimensional memoryview of the screen
    &#34;&#34;&#34;

    return self.game_wrapper.game_area()</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.set_emulation_speed"><code class="name flex">
<span>def <span class="ident">set_emulation_speed</span></span>(<span>self, target_speed)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
<code>target_speed</code>.</p>
<p>The speed is defined as a multiple of real-time. I.e <code>target_speed=2</code> is double speed.</p>
<p>A <code>target_speed</code> of <code>0</code> means unlimited. I.e. fastest possible execution.</p>
<p>Some window types do not implement a frame-limiter, and will always run at full speed.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.tick() # Delays 16.67ms
True
&gt;&gt;&gt; pyboy.set_emulation_speed(0) # Disable limit
&gt;&gt;&gt; pyboy.tick() # As fast as possible
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_speed</code></strong> :&ensp;<code>int</code></dt>
<dd>Target emulation speed as multiplier of real-time.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_emulation_speed(self, target_speed):
    &#34;&#34;&#34;
    Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
    `target_speed`.

    The speed is defined as a multiple of real-time. I.e `target_speed=2` is double speed.

    A `target_speed` of `0` means unlimited. I.e. fastest possible execution.

    Some window types do not implement a frame-limiter, and will always run at full speed.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.tick() # Delays 16.67ms
    True
    &gt;&gt;&gt; pyboy.set_emulation_speed(0) # Disable limit
    &gt;&gt;&gt; pyboy.tick() # As fast as possible
    True
    ```

    Args:
        target_speed (int): Target emulation speed as multiplier of real-time.
    &#34;&#34;&#34;
    if self.initialized and self._plugin_manager.window_null_enabled:
        logger.warning(
            &#39;This window type does not support frame-limiting. `pyboy.set_emulation_speed(...)` will have no effect, as it\&#39;s always running at full speed.&#39;
        )

    if target_speed &gt; 5:
        logger.warning(&#34;The emulation speed might not be accurate when speed-target is higher than 5&#34;)
    self.target_emulationspeed = target_speed</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.symbol_lookup"><code class="name flex">
<span>def <span class="ident">symbol_lookup</span></span>(<span>self, symbol)</span>
</code></dt>
<dd>
<section class="desc"><p>Look up a specific symbol from provided symbols file.</p>
<p>This can be useful in combination with <code><a title="pyboy.PyBoy.memory" href="#pyboy.PyBoy.memory">PyBoy.memory</a></code> or even <code><a title="pyboy.PyBoy.hook_register" href="#pyboy.PyBoy.hook_register">PyBoy.hook_register()</a></code>.</p>
<p>See <code><a title="pyboy.PyBoy.hook_register" href="#pyboy.PyBoy.hook_register">PyBoy.hook_register()</a></code> for how to load symbol into PyBoy.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; # Directly
&gt;&gt;&gt; pyboy.memory[pyboy.symbol_lookup(&quot;Tileset&quot;)]
0
&gt;&gt;&gt; # By bank and address
&gt;&gt;&gt; bank, addr = pyboy.symbol_lookup(&quot;Tileset&quot;)
&gt;&gt;&gt; pyboy.memory[bank, addr]
0
&gt;&gt;&gt; pyboy.memory[bank, addr:addr+10]
[0, 0, 0, 0, 0, 0, 102, 102, 102, 102]

</code></pre>
<h2 id="returns">Returns</h2>
<p>(int, int):
ROM/RAM bank, address</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbol_lookup(self, symbol):
    &#34;&#34;&#34;
    Look up a specific symbol from provided symbols file.

    This can be useful in combination with `PyBoy.memory` or even `PyBoy.hook_register`.

    See `PyBoy.hook_register` for how to load symbol into PyBoy.

    Example:
    ```python
    &gt;&gt;&gt; # Directly
    &gt;&gt;&gt; pyboy.memory[pyboy.symbol_lookup(&#34;Tileset&#34;)]
    0
    &gt;&gt;&gt; # By bank and address
    &gt;&gt;&gt; bank, addr = pyboy.symbol_lookup(&#34;Tileset&#34;)
    &gt;&gt;&gt; pyboy.memory[bank, addr]
    0
    &gt;&gt;&gt; pyboy.memory[bank, addr:addr+10]
    [0, 0, 0, 0, 0, 0, 102, 102, 102, 102]

    ```
    Returns
    -------
    (int, int):
        ROM/RAM bank, address
    &#34;&#34;&#34;
    return self._lookup_symbol(symbol)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.hook_register"><code class="name flex">
<span>def <span class="ident">hook_register</span></span>(<span>self, bank, addr, callback, context)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a hook into a specific bank and memory address.
When the Game Boy executes this address, the provided callback function will be called.</p>
<p>By providing an object as <code>context</code>, you can later get access to information inside and outside of the callback.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; context = &quot;Hello from hook&quot;
&gt;&gt;&gt; def my_callback(context):
...     print(context)
&gt;&gt;&gt; pyboy.hook_register(0, 0x100, my_callback, context)
&gt;&gt;&gt; pyboy.tick(70)
Hello from hook
True

</code></pre>
<p>If a symbol file is loaded, this function can also automatically resolve a bank and address from a symbol. To
enable this, you'll need to place a <code>.sym</code> file next to your ROM, or provide it using:
<code>PyBoy(..., symbols="game_rom.gb.sym")</code>.</p>
<p>Then provide <code>None</code> for <code>bank</code> and the symbol for <code>addr</code> to trigger the automatic lookup.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; # Continued example above
&gt;&gt;&gt; pyboy.hook_register(None, &quot;Main.move&quot;, lambda x: print(x), &quot;Hello from hook2&quot;)
&gt;&gt;&gt; pyboy.tick(80)
Hello from hook2
True

</code></pre>
<p><strong>NOTE</strong>:</p>
<p>Don't register hooks to something that isn't executable (graphics data etc.). This will cause your game to show
weird behavior or crash. Hooks are installed by replacing the instruction at the bank and address with a special
opcode (<code>0xDB</code>). If the address is read by the game instead of executed as code, this value will be read instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bank</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>ROM or RAM bank (None for symbol lookup)</dd>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Address in the Game Boy's address space (str for symbol lookup)</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>func</code></dt>
<dd>A function which takes <code>context</code> as argument</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>object</code></dt>
<dd>Argument to pass to callback when hook is called</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_register(self, bank, addr, callback, context):
    &#34;&#34;&#34;
    Adds a hook into a specific bank and memory address.
    When the Game Boy executes this address, the provided callback function will be called.

    By providing an object as `context`, you can later get access to information inside and outside of the callback.

    Example:
    ```python
    &gt;&gt;&gt; context = &#34;Hello from hook&#34;
    &gt;&gt;&gt; def my_callback(context):
    ...     print(context)
    &gt;&gt;&gt; pyboy.hook_register(0, 0x100, my_callback, context)
    &gt;&gt;&gt; pyboy.tick(70)
    Hello from hook
    True

    ```

    If a symbol file is loaded, this function can also automatically resolve a bank and address from a symbol. To
    enable this, you&#39;ll need to place a `.sym` file next to your ROM, or provide it using:
    `PyBoy(..., symbols=&#34;game_rom.gb.sym&#34;)`.

    Then provide `None` for `bank` and the symbol for `addr` to trigger the automatic lookup.

    Example:
    ```python
    &gt;&gt;&gt; # Continued example above
    &gt;&gt;&gt; pyboy.hook_register(None, &#34;Main.move&#34;, lambda x: print(x), &#34;Hello from hook2&#34;)
    &gt;&gt;&gt; pyboy.tick(80)
    Hello from hook2
    True

    ```

    **NOTE**:

    Don&#39;t register hooks to something that isn&#39;t executable (graphics data etc.). This will cause your game to show
    weird behavior or crash. Hooks are installed by replacing the instruction at the bank and address with a special
    opcode (`0xDB`). If the address is read by the game instead of executed as code, this value will be read instead.

    Args:
        bank (int or None): ROM or RAM bank (None for symbol lookup)
        addr (int or str): Address in the Game Boy&#39;s address space (str for symbol lookup)
        callback (func): A function which takes `context` as argument
        context (object): Argument to pass to callback when hook is called
    &#34;&#34;&#34;
    if bank is None and isinstance(addr, str):
        bank, addr = self._lookup_symbol(addr)

    opcode = self.memory[bank, addr]
    if opcode == 0xDB:
        raise ValueError(&#34;Hook already registered for this bank and address.&#34;)
    self.mb.breakpoint_add(bank, addr)
    bank_addr_opcode = (bank &amp; 0xFF) &lt;&lt; 24 | (addr &amp; 0xFFFF) &lt;&lt; 8 | (opcode &amp; 0xFF)
    logger.debug(&#34;Adding hook for opcode %08x&#34;, bank_addr_opcode)
    self._hooks[bank_addr_opcode] = (callback, context)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.hook_deregister"><code class="name flex">
<span>def <span class="ident">hook_deregister</span></span>(<span>self, bank, addr)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a previously registered hook from a specific bank and memory address.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; context = &quot;Hello from hook&quot;
&gt;&gt;&gt; def my_callback(context):
...     print(context)
&gt;&gt;&gt; pyboy.hook_register(0, 0x2000, my_callback, context)
&gt;&gt;&gt; pyboy.hook_deregister(0, 0x2000)

</code></pre>
<p>This function can also deregister a hook based on a symbol. See <code><a title="pyboy.PyBoy.hook_register" href="#pyboy.PyBoy.hook_register">PyBoy.hook_register()</a></code> for details.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.hook_register(None, &quot;Main&quot;, lambda x: print(x), &quot;Hello from hook&quot;)
&gt;&gt;&gt; pyboy.hook_deregister(None, &quot;Main&quot;)

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bank</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>ROM or RAM bank (None for symbol lookup)</dd>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Address in the Game Boy's address space (str for symbol lookup)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_deregister(self, bank, addr):
    &#34;&#34;&#34;
    Remove a previously registered hook from a specific bank and memory address.

    Example:
    ```python
    &gt;&gt;&gt; context = &#34;Hello from hook&#34;
    &gt;&gt;&gt; def my_callback(context):
    ...     print(context)
    &gt;&gt;&gt; pyboy.hook_register(0, 0x2000, my_callback, context)
    &gt;&gt;&gt; pyboy.hook_deregister(0, 0x2000)

    ```

    This function can also deregister a hook based on a symbol. See `PyBoy.hook_register` for details.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.hook_register(None, &#34;Main&#34;, lambda x: print(x), &#34;Hello from hook&#34;)
    &gt;&gt;&gt; pyboy.hook_deregister(None, &#34;Main&#34;)

    ```

    Args:
        bank (int or None): ROM or RAM bank (None for symbol lookup)
        addr (int or str): Address in the Game Boy&#39;s address space (str for symbol lookup)
    &#34;&#34;&#34;
    if bank is None and isinstance(addr, str):
        bank, addr = self._lookup_symbol(addr)

    breakpoint_meta = self.mb.breakpoint_find(bank, addr)
    if not breakpoint_meta:
        raise ValueError(&#34;Breakpoint not found for bank and addr&#34;)
    _, _, opcode = breakpoint_meta

    self.mb.breakpoint_remove(bank, addr)
    bank_addr_opcode = (bank &amp; 0xFF) &lt;&lt; 24 | (addr &amp; 0xFFFF) &lt;&lt; 8 | (opcode &amp; 0xFF)
    self._hooks.pop(bank_addr_opcode)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.get_sprite"><code class="name flex">
<span>def <span class="ident">get_sprite</span></span>(<span>self, sprite_index)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides a <code><a title="pyboy.api.sprite.Sprite" href="api/sprite.html#pyboy.api.sprite.Sprite">Sprite</a></code> object, which makes the OAM data more presentable. The given index
corresponds to index of the sprite in the "Object Attribute Memory" (OAM).</p>
<p>The Game Boy supports 40 sprites in total. Read more details about it, in the <a href="http://bgb.bircd.org/pandocs.htm">Pan
Docs</a>.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = pyboy.get_sprite(12)
&gt;&gt;&gt; s
Sprite [12]: Position: (-8, -16), Shape: (8, 8), Tiles: (Tile: 0), On screen: False
&gt;&gt;&gt; s.on_screen
False
&gt;&gt;&gt; s.tiles
[Tile: 0]

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Sprite index from 0 to 39.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.api.sprite.Sprite" href="api/sprite.html#pyboy.api.sprite.Sprite">Sprite</a></code>:
Sprite corresponding to the given index.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sprite(self, sprite_index):
    &#34;&#34;&#34;
    Provides a `pyboy.api.sprite.Sprite` object, which makes the OAM data more presentable. The given index
    corresponds to index of the sprite in the &#34;Object Attribute Memory&#34; (OAM).

    The Game Boy supports 40 sprites in total. Read more details about it, in the [Pan
    Docs](http://bgb.bircd.org/pandocs.htm).

    ```python
    &gt;&gt;&gt; s = pyboy.get_sprite(12)
    &gt;&gt;&gt; s
    Sprite [12]: Position: (-8, -16), Shape: (8, 8), Tiles: (Tile: 0), On screen: False
    &gt;&gt;&gt; s.on_screen
    False
    &gt;&gt;&gt; s.tiles
    [Tile: 0]

    ```

    Args:
        index (int): Sprite index from 0 to 39.
    Returns
    -------
    `pyboy.api.sprite.Sprite`:
        Sprite corresponding to the given index.
    &#34;&#34;&#34;
    return Sprite(self.mb, sprite_index)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.get_sprite_by_tile_identifier"><code class="name flex">
<span>def <span class="ident">get_sprite_by_tile_identifier</span></span>(<span>self, tile_identifiers, on_screen=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
<code><a title="pyboy.PyBoy.get_sprite" href="#pyboy.PyBoy.get_sprite">PyBoy.get_sprite()</a></code> function to get a <code><a title="pyboy.api.sprite.Sprite" href="api/sprite.html#pyboy.api.sprite.Sprite">Sprite</a></code> object.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(pyboy.get_sprite_by_tile_identifier([43, 123]))
[[0, 2, 4], []]

</code></pre>
<p>Meaning, that tile identifier <code>43</code> is found at the sprite indexes: 0, 2, and 4, while tile identifier
<code>123</code> was not found anywhere.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifiers</code></strong> :&ensp;<code>list</code></dt>
<dd>List of tile identifiers (int)</dd>
<dt><strong><code>on_screen</code></strong> :&ensp;<code>bool</code></dt>
<dd>Require that the matched sprite is on screen</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list:</code></dt>
<dd>list of sprite matches for every tile identifier in the input</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sprite_by_tile_identifier(self, tile_identifiers, on_screen=True):
    &#34;&#34;&#34;
    Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
    identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
    `pyboy.PyBoy.get_sprite` function to get a `pyboy.api.sprite.Sprite` object.

    Example:
    ```python
    &gt;&gt;&gt; print(pyboy.get_sprite_by_tile_identifier([43, 123]))
    [[0, 2, 4], []]

    ```

    Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2, and 4, while tile identifier
    `123` was not found anywhere.

    Args:
        identifiers (list): List of tile identifiers (int)
        on_screen (bool): Require that the matched sprite is on screen

    Returns
    -------
    list:
        list of sprite matches for every tile identifier in the input
    &#34;&#34;&#34;

    matches = []
    for i in tile_identifiers:
        match = []
        for s in range(constants.SPRITES):
            sprite = Sprite(self.mb, s)
            for t in sprite.tiles:
                if t.tile_identifier == i and (not on_screen or (on_screen and sprite.on_screen)):
                    match.append(s)
        matches.append(match)
    return matches</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.get_tile"><code class="name flex">
<span>def <span class="ident">get_tile</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy can have 384 tiles loaded in memory at once (768 for Game Boy Color). Use this method to get a
<code><a title="pyboy.api.tile.Tile" href="api/tile.html#pyboy.api.tile.Tile">Tile</a></code>-object for given identifier.</p>
<p>The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
the <code><a title="pyboy.api.tile.Tile" href="api/tile.html#pyboy.api.tile.Tile">Tile</a></code> object for more information.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = pyboy.get_tile(2)
&gt;&gt;&gt; t
Tile: 2
&gt;&gt;&gt; t.shape
(8, 8)

</code></pre>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.api.tile.Tile" href="api/tile.html#pyboy.api.tile.Tile">Tile</a></code>:
A Tile object for the given identifier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tile(self, identifier):
    &#34;&#34;&#34;
    The Game Boy can have 384 tiles loaded in memory at once (768 for Game Boy Color). Use this method to get a
    `pyboy.api.tile.Tile`-object for given identifier.

    The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
    the `pyboy.api.tile.Tile` object for more information.

    Example:
    ```python
    &gt;&gt;&gt; t = pyboy.get_tile(2)
    &gt;&gt;&gt; t
    Tile: 2
    &gt;&gt;&gt; t.shape
    (8, 8)

    ```

    Returns
    -------
    `pyboy.api.tile.Tile`:
        A Tile object for the given identifier.
    &#34;&#34;&#34;
    return Tile(self.mb, identifier=identifier)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.PyBoyMemoryView"><code class="flex name class">
<span>class <span class="ident">PyBoyMemoryView</span></span>
<span>(</span><span>mb)</span>
</code></dt>
<dd>
<section class="desc"><p>This class cannot be used directly, but is accessed through <code><a title="pyboy.PyBoy.memory" href="#pyboy.PyBoy.memory">PyBoy.memory</a></code>.</p>
<p>This class serves four purposes: Reading memory (ROM/RAM), writing memory (ROM/RAM), overriding memory (ROM/RAM) and special registers.</p>
<p>See the <a href="https://gbdev.io/pandocs/Memory_Map.html">Pan Docs: Memory Map</a> for a great overview of the memory space.</p>
<p>Memory can be accessed as individual bytes (<code>pyboy.memory[0x00]</code>) or as slices (<code>pyboy.memory[0x00:0x10]</code>). And if
applicable, a specific ROM/RAM bank can be defined before the address (<code>pyboy.memory[0, 0x00]</code> or <code>pyboy.memory[0, 0x00:0x10]</code>).</p>
<p>The boot ROM is accessed using the special "-1" ROM bank.</p>
<p>The find addresses of interest, either search online for something like: "[game title] RAM map", or find them yourself
using <code><a title="pyboy.PyBoy.memory_scanner" href="#pyboy.PyBoy.memory_scanner">PyBoy.memory_scanner</a></code>.</p>
<p><strong>Read:</strong></p>
<p>If you're developing a bot or AI with this API, you're most likely going to be using read the most. This is how you
would efficiently read the score, time, coins, positions etc. in a game's memory.</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.memory[0x0000] # Read one byte at address 0x0000
49
&gt;&gt;&gt; pyboy.memory[0x0000:0x0010] # Read 16 bytes from 0x0000 to 0x0010 (excluding 0x0010)
[49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
&gt;&gt;&gt; pyboy.memory[-1, 0x0000:0x0010] # Read 16 bytes from 0x0000 to 0x0010 (excluding 0x0010) from the boot ROM
[49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
&gt;&gt;&gt; pyboy.memory[0, 0x0000:0x0010] # Read 16 bytes from 0x0000 to 0x0010 (excluding 0x0010) from ROM bank 0
[64, 65, 66, 67, 68, 69, 70, 65, 65, 65, 71, 65, 65, 65, 72, 73]
&gt;&gt;&gt; pyboy.memory[2, 0xA000] # Read from external RAM on cartridge (if any) from bank 2 at address 0xA000
0
</code></pre>
<p><strong>Write:</strong></p>
<p>Writing to Game Boy memory can be complicated because of the limited address space. There's a lot of memory that
isn't directly accessible, and can be hidden through "memory banking". This means that the same address range
(for example 0x4000 to 0x8000) can change depending on what state the game is in.</p>
<p>If you want to change an address in the ROM, then look at override below. Issuing writes to the ROM area actually
sends commands to the <a href="https://gbdev.io/pandocs/MBCs.html#mbcs">Memory Bank Controller (MBC)</a> on the cartridge.</p>
<p>A write is done by assigning to the <code><a title="pyboy.PyBoy.memory" href="#pyboy.PyBoy.memory">PyBoy.memory</a></code> object. It's recommended to define the bank to avoid mistakes
(<code>pyboy.memory[2, 0xA000]=1</code>). Without defining the bank, PyBoy will pick the current bank for the given address if
needed (<code>pyboy.memory[0xA000]=1</code>).</p>
<p>At this point, all reads will return a new list of the values in the given range. The slices will not reference back to the PyBoy memory. This feature might come in the future.</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.memory[0xC000] = 123 # Write to WRAM at address 0xC000
&gt;&gt;&gt; pyboy.memory[0xC000:0xC00A] = [0,1,2,3,4,5,6,7,8,9] # Write to WRAM from address 0xC000 to 0xC00A
&gt;&gt;&gt; pyboy.memory[0xC010:0xC01A] = 0 # Write to WRAM from address 0xC010 to 0xC01A
&gt;&gt;&gt; pyboy.memory[0x1000] = 123 # Not writing 123 at address 0x1000! This sends a command to the cartridge's MBC.
&gt;&gt;&gt; pyboy.memory[2, 0xA000] = 123 # Write to external RAM on cartridge (if any) for bank 2 at address 0xA000
&gt;&gt;&gt; # Game Boy Color (CGB) only:
&gt;&gt;&gt; pyboy_cgb.memory[1, 0x8000] = 25 # Write to VRAM bank 1 at address 0xD000 when in CGB mode
&gt;&gt;&gt; pyboy_cgb.memory[6, 0xD000] = 25 # Write to WRAM bank 6 at address 0xD000 when in CGB mode
</code></pre>
<p><strong>Override:</strong></p>
<p>Override data at a given memory address of the Game Boy's ROM.</p>
<p>This can be used to reprogram a game ROM to change its behavior.</p>
<p>This will not let your override RAM or a special register. This will let you override data in the ROM at any given bank.
This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000 can be changed from the MBC.</p>
<p><em>NOTE</em>: Any changes here are not saved or loaded to game states! Use this function with caution and reapply
any overrides when reloading the ROM.</p>
<p>To override, it's required to provide the ROM-bank you're changing. Otherwise, it'll be considered a regular 'write' as described above.</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.memory[0, 0x0010] = 10 # Override ROM-bank 0 at address 0x0010
&gt;&gt;&gt; pyboy.memory[0, 0x0010:0x001A] = [0,1,2,3,4,5,6,7,8,9] # Override ROM-bank 0 at address 0x0010 to 0x001A
&gt;&gt;&gt; pyboy.memory[-1, 0x0010] = 10 # Override boot ROM at address 0x0010
&gt;&gt;&gt; pyboy.memory[1, 0x6000] = 12 # Override ROM-bank 1 at address 0x6000
&gt;&gt;&gt; pyboy.memory[0x1000] = 12 # This will not override, as there is no ROM bank assigned!
</code></pre>
<p><strong>Special Registers:</strong></p>
<p>The Game Boy has a range of memory addresses known as <a href="https://gbdev.io/pandocs/Hardware_Reg_List.html">hardware registers</a>. These control parts of the hardware like LCD,
Timer, DMA, serial and so on. Even though they might appear as regular RAM addresses, reading/writing these addresses
often results in special side-effects.</p>
<p>The <a href="https://gbdev.io/pandocs/Timer_and_Divider_Registers.html#ff04--div-divider-register">DIV (0xFF04) register</a> for example provides a number that increments 16 thousand times each second. This can be
used as a source of randomness in games. If you read the value, you'll get a pseudo-random number. But if you write
<em>any</em> value to the register, it'll reset to zero.</p>
<pre><code class="language-python">&gt;&gt;&gt; pyboy.memory[0xFF04] # DIV register
163
&gt;&gt;&gt; pyboy.memory[0xFF04] = 123 # Trying to write to it will always reset it to zero
&gt;&gt;&gt; pyboy.memory[0xFF04]
0
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyBoyMemoryView:
    &#34;&#34;&#34;
    This class cannot be used directly, but is accessed through `PyBoy.memory`.

    This class serves four purposes: Reading memory (ROM/RAM), writing memory (ROM/RAM), overriding memory (ROM/RAM) and special registers.

    See the [Pan Docs: Memory Map](https://gbdev.io/pandocs/Memory_Map.html) for a great overview of the memory space.

    Memory can be accessed as individual bytes (`pyboy.memory[0x00]`) or as slices (`pyboy.memory[0x00:0x10]`). And if
    applicable, a specific ROM/RAM bank can be defined before the address (`pyboy.memory[0, 0x00]` or `pyboy.memory[0, 0x00:0x10]`).

    The boot ROM is accessed using the special &#34;-1&#34; ROM bank.

    The find addresses of interest, either search online for something like: &#34;[game title] RAM map&#34;, or find them yourself
    using `PyBoy.memory_scanner`.

    **Read:**

    If you&#39;re developing a bot or AI with this API, you&#39;re most likely going to be using read the most. This is how you
    would efficiently read the score, time, coins, positions etc. in a game&#39;s memory.

    ```python
    &gt;&gt;&gt; pyboy.memory[0x0000] # Read one byte at address 0x0000
    49
    &gt;&gt;&gt; pyboy.memory[0x0000:0x0010] # Read 16 bytes from 0x0000 to 0x0010 (excluding 0x0010)
    [49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
    &gt;&gt;&gt; pyboy.memory[-1, 0x0000:0x0010] # Read 16 bytes from 0x0000 to 0x0010 (excluding 0x0010) from the boot ROM
    [49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
    &gt;&gt;&gt; pyboy.memory[0, 0x0000:0x0010] # Read 16 bytes from 0x0000 to 0x0010 (excluding 0x0010) from ROM bank 0
    [64, 65, 66, 67, 68, 69, 70, 65, 65, 65, 71, 65, 65, 65, 72, 73]
    &gt;&gt;&gt; pyboy.memory[2, 0xA000] # Read from external RAM on cartridge (if any) from bank 2 at address 0xA000
    0
    ```

    **Write:**

    Writing to Game Boy memory can be complicated because of the limited address space. There&#39;s a lot of memory that
    isn&#39;t directly accessible, and can be hidden through &#34;memory banking&#34;. This means that the same address range
    (for example 0x4000 to 0x8000) can change depending on what state the game is in.

    If you want to change an address in the ROM, then look at override below. Issuing writes to the ROM area actually
    sends commands to the [Memory Bank Controller (MBC)](https://gbdev.io/pandocs/MBCs.html#mbcs) on the cartridge.

    A write is done by assigning to the `PyBoy.memory` object. It&#39;s recommended to define the bank to avoid mistakes
    (`pyboy.memory[2, 0xA000]=1`). Without defining the bank, PyBoy will pick the current bank for the given address if
    needed (`pyboy.memory[0xA000]=1`).

    At this point, all reads will return a new list of the values in the given range. The slices will not reference back to the PyBoy memory. This feature might come in the future.

    ```python
    &gt;&gt;&gt; pyboy.memory[0xC000] = 123 # Write to WRAM at address 0xC000
    &gt;&gt;&gt; pyboy.memory[0xC000:0xC00A] = [0,1,2,3,4,5,6,7,8,9] # Write to WRAM from address 0xC000 to 0xC00A
    &gt;&gt;&gt; pyboy.memory[0xC010:0xC01A] = 0 # Write to WRAM from address 0xC010 to 0xC01A
    &gt;&gt;&gt; pyboy.memory[0x1000] = 123 # Not writing 123 at address 0x1000! This sends a command to the cartridge&#39;s MBC.
    &gt;&gt;&gt; pyboy.memory[2, 0xA000] = 123 # Write to external RAM on cartridge (if any) for bank 2 at address 0xA000
    &gt;&gt;&gt; # Game Boy Color (CGB) only:
    &gt;&gt;&gt; pyboy_cgb.memory[1, 0x8000] = 25 # Write to VRAM bank 1 at address 0xD000 when in CGB mode
    &gt;&gt;&gt; pyboy_cgb.memory[6, 0xD000] = 25 # Write to WRAM bank 6 at address 0xD000 when in CGB mode
    ```

    **Override:**

    Override data at a given memory address of the Game Boy&#39;s ROM.

    This can be used to reprogram a game ROM to change its behavior.

    This will not let your override RAM or a special register. This will let you override data in the ROM at any given bank.
    This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000 can be changed from the MBC.

    _NOTE_: Any changes here are not saved or loaded to game states! Use this function with caution and reapply
    any overrides when reloading the ROM.

    To override, it&#39;s required to provide the ROM-bank you&#39;re changing. Otherwise, it&#39;ll be considered a regular &#39;write&#39; as described above.

    ```python
    &gt;&gt;&gt; pyboy.memory[0, 0x0010] = 10 # Override ROM-bank 0 at address 0x0010
    &gt;&gt;&gt; pyboy.memory[0, 0x0010:0x001A] = [0,1,2,3,4,5,6,7,8,9] # Override ROM-bank 0 at address 0x0010 to 0x001A
    &gt;&gt;&gt; pyboy.memory[-1, 0x0010] = 10 # Override boot ROM at address 0x0010
    &gt;&gt;&gt; pyboy.memory[1, 0x6000] = 12 # Override ROM-bank 1 at address 0x6000
    &gt;&gt;&gt; pyboy.memory[0x1000] = 12 # This will not override, as there is no ROM bank assigned!
    ```

    **Special Registers:**

    The Game Boy has a range of memory addresses known as [hardware registers](https://gbdev.io/pandocs/Hardware_Reg_List.html). These control parts of the hardware like LCD,
    Timer, DMA, serial and so on. Even though they might appear as regular RAM addresses, reading/writing these addresses
    often results in special side-effects.

    The [DIV (0xFF04) register](https://gbdev.io/pandocs/Timer_and_Divider_Registers.html#ff04--div-divider-register) for example provides a number that increments 16 thousand times each second. This can be
    used as a source of randomness in games. If you read the value, you&#39;ll get a pseudo-random number. But if you write
    *any* value to the register, it&#39;ll reset to zero.

    ```python
    &gt;&gt;&gt; pyboy.memory[0xFF04] # DIV register
    163
    &gt;&gt;&gt; pyboy.memory[0xFF04] = 123 # Trying to write to it will always reset it to zero
    &gt;&gt;&gt; pyboy.memory[0xFF04]
    0
    ```

    &#34;&#34;&#34;
    def __init__(self, mb):
        self.mb = mb

    def _fix_slice(self, addr):
        if addr.start is None:
            return (-1, 0, 0)
        if addr.stop is None:
            return (0, -1, 0)
        start = addr.start
        stop = addr.stop
        if start &gt; stop:
            return (-1, -1, 0)
        if addr.step is None:
            step = 1
        else:
            step = addr.step
        return start, stop, step

    def __getitem__(self, addr):
        is_bank = isinstance(addr, tuple)
        bank = 0
        if is_bank:
            bank, addr = addr
            assert isinstance(bank, int), &#34;Bank has to be integer. Slicing is not supported.&#34;
        is_single = isinstance(addr, int)
        if not is_single:
            start, stop, step = self._fix_slice(addr)
            assert start &gt;= 0 or stop &gt;= 0, &#34;Start address has to come before end address&#34;
            assert start &gt;= 0, &#34;Start address required&#34;
            assert stop &gt;= 0, &#34;End address required&#34;
            return self.__getitem(start, stop, step, bank, is_single, is_bank)
        else:
            return self.__getitem(addr, 0, 1, bank, is_single, is_bank)

    def __getitem(self, start, stop, step, bank, is_single, is_bank):
        slice_length = (stop-start) // step
        if is_bank:
            # Reading a specific bank
            if start &lt; 0x8000:
                if start &gt;= 0x4000:
                    start -= 0x4000
                    stop -= 0x4000
                # Cartridge ROM Banks
                assert stop &lt; 0x4000, &#34;Out of bounds for reading ROM bank&#34;
                if bank == -1:
                    assert start &lt;= 0xFF, &#34;Start address out of range for bootrom&#34;
                    assert stop &lt;= 0xFF, &#34;Start address out of range for bootrom&#34;
                    if not is_single:
                        mem_slice = [0] * slice_length
                        for x in range(start, stop, step):
                            mem_slice[(x-start) // step] = self.mb.bootrom.bootrom[x]
                        return mem_slice
                    else:
                        return self.mb.bootrom.bootrom[start]
                else:
                    assert bank &lt;= self.mb.cartridge.external_rom_count, &#34;ROM Bank out of range&#34;
                    if not is_single:
                        mem_slice = [0] * slice_length
                        for x in range(start, stop, step):
                            mem_slice[(x-start) // step] = self.mb.cartridge.rombanks[bank, x]
                        return mem_slice
                    else:
                        return self.mb.cartridge.rombanks[bank, start]
            elif start &lt; 0xA000:
                start -= 0x8000
                stop -= 0x8000
                # CGB VRAM Banks
                assert self.mb.cgb or (bank == 0), &#34;Selecting bank of VRAM is only supported for CGB mode&#34;
                assert stop &lt; 0x2000, &#34;Out of bounds for reading VRAM bank&#34;
                assert bank &lt;= 1, &#34;VRAM Bank out of range&#34;

                if bank == 0:
                    if not is_single:
                        mem_slice = [0] * slice_length
                        for x in range(start, stop, step):
                            mem_slice[(x-start) // step] = self.mb.lcd.VRAM0[x]
                        return mem_slice
                    else:
                        return self.mb.lcd.VRAM0[start]
                else:
                    if not is_single:
                        mem_slice = [0] * slice_length
                        for x in range(start, stop, step):
                            mem_slice[(x-start) // step] = self.mb.lcd.VRAM1[x]
                        return mem_slice
                    else:
                        return self.mb.lcd.VRAM1[start]
            elif start &lt; 0xC000:
                start -= 0xA000
                stop -= 0xA000
                # Cartridge RAM banks
                assert stop &lt; 0x2000, &#34;Out of bounds for reading cartridge RAM bank&#34;
                assert bank &lt;= self.mb.cartridge.external_ram_count, &#34;ROM Bank out of range&#34;
                if not is_single:
                    mem_slice = [0] * slice_length
                    for x in range(start, stop, step):
                        mem_slice[(x-start) // step] = self.mb.cartridge.rambanks[bank, x]
                    return mem_slice
                else:
                    return self.mb.cartridge.rambanks[bank, start]
            elif start &lt; 0xE000:
                start -= 0xC000
                stop -= 0xC000
                if start &gt;= 0x1000:
                    start -= 0x1000
                    stop -= 0x1000
                # CGB VRAM banks
                assert self.mb.cgb or (bank == 0), &#34;Selecting bank of WRAM is only supported for CGB mode&#34;
                assert stop &lt; 0x1000, &#34;Out of bounds for reading VRAM bank&#34;
                assert bank &lt;= 7, &#34;WRAM Bank out of range&#34;
                if not is_single:
                    mem_slice = [0] * slice_length
                    for x in range(start, stop, step):
                        mem_slice[(x-start) // step] = self.mb.ram.internal_ram0[x + bank*0x1000]
                    return mem_slice
                else:
                    return self.mb.ram.internal_ram0[start + bank*0x1000]
            else:
                assert None, &#34;Invalid memory address for bank&#34;
        elif not is_single:
            # Reading slice of memory space
            mem_slice = [0] * slice_length
            for x in range(start, stop, step):
                mem_slice[(x-start) // step] = self.mb.getitem(x)
            return mem_slice
        else:
            # Reading specific address of memory space
            return self.mb.getitem(start)

    def __setitem__(self, addr, v):
        is_bank = isinstance(addr, tuple)
        bank = 0
        if is_bank:
            bank, addr = addr
            assert isinstance(bank, int), &#34;Bank has to be integer. Slicing is not supported.&#34;
        is_single = isinstance(addr, int)
        if not is_single:
            start, stop, step = self._fix_slice(addr)
            assert start &gt;= 0, &#34;Start address required&#34;
            assert stop &gt;= 0, &#34;End address required&#34;
            self.__setitem(start, stop, step, v, bank, is_single, is_bank)
        else:
            self.__setitem(addr, 0, 0, v, bank, is_single, is_bank)

    def __setitem(self, start, stop, step, v, bank, is_single, is_bank):
        if is_bank:
            # Writing a specific bank
            if start &lt; 0x8000:
                &#34;&#34;&#34;
                Override one byte at a given memory address of the Game Boy&#39;s ROM.

                This will let you override data in the ROM at any given bank. This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000 can be changed from the MBC.

                __NOTE__: Any changes here are not saved or loaded to game states! Use this function with caution and reapply
                any overrides when reloading the ROM.

                If you need to change a RAM address, see `pyboy.PyBoy.memory`.

                Args:
                    rom_bank (int): ROM bank to do the overwrite in
                    addr (int): Address to write the byte inside the ROM bank
                    value (int): A byte of data
                &#34;&#34;&#34;
                if start &gt;= 0x4000:
                    start -= 0x4000
                    stop -= 0x4000
                # Cartridge ROM Banks
                assert stop &lt; 0x4000, &#34;Out of bounds for reading ROM bank&#34;
                assert bank &lt;= self.mb.cartridge.external_rom_count, &#34;ROM Bank out of range&#34;

                # TODO: If you change a RAM value outside of the ROM banks above, the memory value will stay the same no matter
                # what the game writes to the address. This can be used so freeze the value for health, cash etc.
                if bank == -1:
                    assert start &lt;= 0xFF, &#34;Start address out of range for bootrom&#34;
                    assert stop &lt;= 0xFF, &#34;Start address out of range for bootrom&#34;
                    if not is_single:
                        # Writing slice of memory space
                        if hasattr(v, &#34;__iter__&#34;):
                            assert (stop-start) // step == len(v), &#34;slice does not match length of data&#34;
                            _v = iter(v)
                            for x in range(start, stop, step):
                                self.mb.bootrom.bootrom[x] = next(_v)
                        else:
                            for x in range(start, stop, step):
                                self.mb.bootrom.bootrom[x] = v
                    else:
                        self.mb.bootrom.bootrom[start] = v
                else:
                    if not is_single:
                        # Writing slice of memory space
                        if hasattr(v, &#34;__iter__&#34;):
                            assert (stop-start) // step == len(v), &#34;slice does not match length of data&#34;
                            _v = iter(v)
                            for x in range(start, stop, step):
                                self.mb.cartridge.overrideitem(bank, x, next(_v))
                        else:
                            for x in range(start, stop, step):
                                self.mb.cartridge.overrideitem(bank, x, v)
                    else:
                        self.mb.cartridge.overrideitem(bank, start, v)

            elif start &lt; 0xA000:
                start -= 0x8000
                stop -= 0x8000
                # CGB VRAM Banks
                assert self.mb.cgb or (bank == 0), &#34;Selecting bank of VRAM is only supported for CGB mode&#34;
                assert stop &lt; 0x2000, &#34;Out of bounds for reading VRAM bank&#34;
                assert bank &lt;= 1, &#34;VRAM Bank out of range&#34;

                if bank == 0:
                    if not is_single:
                        # Writing slice of memory space
                        if hasattr(v, &#34;__iter__&#34;):
                            assert (stop-start) // step == len(v), &#34;slice does not match length of data&#34;
                            _v = iter(v)
                            for x in range(start, stop, step):
                                self.mb.lcd.VRAM0[x] = next(_v)
                        else:
                            for x in range(start, stop, step):
                                self.mb.lcd.VRAM0[x] = v
                    else:
                        self.mb.lcd.VRAM0[start] = v
                else:
                    if not is_single:
                        # Writing slice of memory space
                        if hasattr(v, &#34;__iter__&#34;):
                            assert (stop-start) // step == len(v), &#34;slice does not match length of data&#34;
                            _v = iter(v)
                            for x in range(start, stop, step):
                                self.mb.lcd.VRAM1[x] = next(_v)
                        else:
                            for x in range(start, stop, step):
                                self.mb.lcd.VRAM1[x] = v
                    else:
                        self.mb.lcd.VRAM1[start] = v
            elif start &lt; 0xC000:
                start -= 0xA000
                stop -= 0xA000
                # Cartridge RAM banks
                assert stop &lt; 0x2000, &#34;Out of bounds for reading cartridge RAM bank&#34;
                assert bank &lt;= self.mb.cartridge.external_ram_count, &#34;ROM Bank out of range&#34;
                if not is_single:
                    # Writing slice of memory space
                    if hasattr(v, &#34;__iter__&#34;):
                        assert (stop-start) // step == len(v), &#34;slice does not match length of data&#34;
                        _v = iter(v)
                        for x in range(start, stop, step):
                            self.mb.cartridge.rambanks[bank, x] = next(_v)
                    else:
                        for x in range(start, stop, step):
                            self.mb.cartridge.rambanks[bank, x] = v
                else:
                    self.mb.cartridge.rambanks[bank, start] = v
            elif start &lt; 0xE000:
                start -= 0xC000
                stop -= 0xC000
                if start &gt;= 0x1000:
                    start -= 0x1000
                    stop -= 0x1000
                # CGB VRAM banks
                assert self.mb.cgb or (bank == 0), &#34;Selecting bank of WRAM is only supported for CGB mode&#34;
                assert stop &lt; 0x1000, &#34;Out of bounds for reading VRAM bank&#34;
                assert bank &lt;= 7, &#34;WRAM Bank out of range&#34;
                if not is_single:
                    # Writing slice of memory space
                    if hasattr(v, &#34;__iter__&#34;):
                        assert (stop-start) // step == len(v), &#34;slice does not match length of data&#34;
                        _v = iter(v)
                        for x in range(start, stop, step):
                            self.mb.ram.internal_ram0[x + bank*0x1000] = next(_v)
                    else:
                        for x in range(start, stop, step):
                            self.mb.ram.internal_ram0[x + bank*0x1000] = v
                else:
                    self.mb.ram.internal_ram0[start + bank*0x1000] = v
            else:
                assert None, &#34;Invalid memory address for bank&#34;
        elif not is_single:
            # Writing slice of memory space
            if hasattr(v, &#34;__iter__&#34;):
                assert (stop-start) // step == len(v), &#34;slice does not match length of data&#34;
                _v = iter(v)
                for x in range(start, stop, step):
                    self.mb.setitem(x, next(_v))
            else:
                for x in range(start, stop, step):
                    self.mb.setitem(x, v)
        else:
            # Writing specific address of memory space
            self.mb.setitem(start, v)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyboy.api" href="api/index.html">pyboy.api</a></code></li>
<li><code><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code></li>
<li><code><a title="pyboy.utils" href="utils.html">pyboy.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.PyBoy" href="#pyboy.PyBoy">PyBoy</a></code></h4>
<ul class="">
<li><code><a title="pyboy.PyBoy.tick" href="#pyboy.PyBoy.tick">tick</a></code></li>
<li><code><a title="pyboy.PyBoy.stop" href="#pyboy.PyBoy.stop">stop</a></code></li>
<li><code><a title="pyboy.PyBoy.button" href="#pyboy.PyBoy.button">button</a></code></li>
<li><code><a title="pyboy.PyBoy.button_press" href="#pyboy.PyBoy.button_press">button_press</a></code></li>
<li><code><a title="pyboy.PyBoy.button_release" href="#pyboy.PyBoy.button_release">button_release</a></code></li>
<li><code><a title="pyboy.PyBoy.send_input" href="#pyboy.PyBoy.send_input">send_input</a></code></li>
<li><code><a title="pyboy.PyBoy.save_state" href="#pyboy.PyBoy.save_state">save_state</a></code></li>
<li><code><a title="pyboy.PyBoy.load_state" href="#pyboy.PyBoy.load_state">load_state</a></code></li>
<li><code><a title="pyboy.PyBoy.game_area_dimensions" href="#pyboy.PyBoy.game_area_dimensions">game_area_dimensions</a></code></li>
<li><code><a title="pyboy.PyBoy.game_area_collision" href="#pyboy.PyBoy.game_area_collision">game_area_collision</a></code></li>
<li><code><a title="pyboy.PyBoy.game_area_mapping" href="#pyboy.PyBoy.game_area_mapping">game_area_mapping</a></code></li>
<li><code><a title="pyboy.PyBoy.game_area" href="#pyboy.PyBoy.game_area">game_area</a></code></li>
<li><code><a title="pyboy.PyBoy.set_emulation_speed" href="#pyboy.PyBoy.set_emulation_speed">set_emulation_speed</a></code></li>
<li><code><a title="pyboy.PyBoy.symbol_lookup" href="#pyboy.PyBoy.symbol_lookup">symbol_lookup</a></code></li>
<li><code><a title="pyboy.PyBoy.hook_register" href="#pyboy.PyBoy.hook_register">hook_register</a></code></li>
<li><code><a title="pyboy.PyBoy.hook_deregister" href="#pyboy.PyBoy.hook_deregister">hook_deregister</a></code></li>
<li><code><a title="pyboy.PyBoy.get_sprite" href="#pyboy.PyBoy.get_sprite">get_sprite</a></code></li>
<li><code><a title="pyboy.PyBoy.get_sprite_by_tile_identifier" href="#pyboy.PyBoy.get_sprite_by_tile_identifier">get_sprite_by_tile_identifier</a></code></li>
<li><code><a title="pyboy.PyBoy.get_tile" href="#pyboy.PyBoy.get_tile">get_tile</a></code></li>
<li><code><a title="pyboy.PyBoy.screen" href="#pyboy.PyBoy.screen">screen</a></code></li>
<li><code><a title="pyboy.PyBoy.memory" href="#pyboy.PyBoy.memory">memory</a></code></li>
<li><code><a title="pyboy.PyBoy.memory_scanner" href="#pyboy.PyBoy.memory_scanner">memory_scanner</a></code></li>
<li><code><a title="pyboy.PyBoy.tilemap_background" href="#pyboy.PyBoy.tilemap_background">tilemap_background</a></code></li>
<li><code><a title="pyboy.PyBoy.tilemap_window" href="#pyboy.PyBoy.tilemap_window">tilemap_window</a></code></li>
<li><code><a title="pyboy.PyBoy.cartridge_title" href="#pyboy.PyBoy.cartridge_title">cartridge_title</a></code></li>
<li><code><a title="pyboy.PyBoy.game_wrapper" href="#pyboy.PyBoy.game_wrapper">game_wrapper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.PyBoyMemoryView" href="#pyboy.PyBoyMemoryView">PyBoyMemoryView</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>