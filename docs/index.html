<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyboy API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:0.8em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# License: See LICENSE.md file
# GitHub: https://github.com/Baekalfen/PyBoy
#

__pdoc__ = {
    &#34;core&#34;: False,
    &#34;logger&#34;: False,
    &#34;pyboy&#34;: False,
    &#34;utils&#34;: False,
}
__all__ = [&#34;PyBoy&#34;, &#34;WindowEvent&#34;]

from .pyboy import PyBoy
from .utils import WindowEvent</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyboy.botsupport" href="botsupport/index.html">pyboy.botsupport</a></code></dt>
<dd>
<section class="desc"><p>Tools to help interfacing with the Game Boy hardware</p></section>
</dd>
<dt><code class="name"><a title="pyboy.openai_gym" href="openai_gym.html">pyboy.openai_gym</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code></dt>
<dd>
<section class="desc"><p>Plugins that extend PyBoy's functionality. The only publicly exposed, are the game wrappers.</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.PyBoy"><code class="flex name class">
<span>class <span class="ident">PyBoy</span></span>
<span>(</span><span>gamerom_file, *, bootrom_file=None, profiling=False, disable_renderer=False, sound=False, cgb=None, randomize=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>PyBoy is loadable as an object in Python. This means, it can be initialized from another script, and be
controlled and probed by the script. It is supported to spawn multiple emulators, just instantiate the class
multiple times.</p>
<p>This object, <code><a title="pyboy.WindowEvent" href="#pyboy.WindowEvent">WindowEvent</a></code>, and the <code><a title="pyboy.botsupport" href="botsupport/index.html">pyboy.botsupport</a></code> module, are the only official user-facing
interfaces. All other parts of the emulator, are subject to change.</p>
<p>A range of methods are exposed, which should allow for complete control of the emulator. Please open an issue on
GitHub, if other methods are needed for your projects. Take a look at <code>interface_example.py</code> or <code>tetris_bot.py</code>
for a crude "bot", which interacts with the game.</p>
<p>Only the <code>gamerom_file</code> argument is required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gamerom_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Filepath to a game-ROM for Game Boy or Game Boy Color.</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<p>bootrom_file (str): Filepath to a boot-ROM to use. If unsure, specify <code>None</code>.
profiling (bool): Profile the emulator and report opcode usage (internal use).
disable_renderer (bool): Can be used to optimize performance, by internally disable rendering of the screen.
color_palette (tuple): Specify the color palette to use for rendering.</p>
<p>Other keyword arguments may exist for plugins that are not listed here. They can be viewed with the
<code>parser_arguments()</code> method in the pyboy.plugins.manager module, or by running pyboy &ndash;help in the terminal.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyBoy:
    def __init__(
        self,
        gamerom_file,
        *,
        bootrom_file=None,
        profiling=False,
        disable_renderer=False,
        sound=False,
        cgb=None,
        randomize=False,
        **kwargs
    ):
        &#34;&#34;&#34;
        PyBoy is loadable as an object in Python. This means, it can be initialized from another script, and be
        controlled and probed by the script. It is supported to spawn multiple emulators, just instantiate the class
        multiple times.

        This object, `pyboy.WindowEvent`, and the `pyboy.botsupport` module, are the only official user-facing
        interfaces. All other parts of the emulator, are subject to change.

        A range of methods are exposed, which should allow for complete control of the emulator. Please open an issue on
        GitHub, if other methods are needed for your projects. Take a look at `interface_example.py` or `tetris_bot.py`
        for a crude &#34;bot&#34;, which interacts with the game.

        Only the `gamerom_file` argument is required.

        Args:
            gamerom_file (str): Filepath to a game-ROM for Game Boy or Game Boy Color.

        Kwargs:
            bootrom_file (str): Filepath to a boot-ROM to use. If unsure, specify `None`.
            profiling (bool): Profile the emulator and report opcode usage (internal use).
            disable_renderer (bool): Can be used to optimize performance, by internally disable rendering of the screen.
            color_palette (tuple): Specify the color palette to use for rendering.

        Other keyword arguments may exist for plugins that are not listed here. They can be viewed with the
        `parser_arguments()` method in the pyboy.plugins.manager module, or by running pyboy --help in the terminal.
        &#34;&#34;&#34;

        self.initialized = False

        for k, v in defaults.items():
            if k not in kwargs:
                kwargs[k] = kwargs.get(k, defaults[k])

        if not os.path.isfile(gamerom_file):
            raise FileNotFoundError(f&#34;ROM file {gamerom_file} was not found!&#34;)
        self.gamerom_file = gamerom_file

        self.mb = Motherboard(
            gamerom_file,
            bootrom_file or kwargs.get(&#34;bootrom&#34;), # Our current way to provide cli arguments is broken
            kwargs[&#34;color_palette&#34;],
            disable_renderer,
            sound,
            cgb,
            randomize=randomize,
            profiling=profiling,
        )

        # Performance measures
        self.avg_pre = 0
        self.avg_tick = 0
        self.avg_post = 0

        # Absolute frame count of the emulation
        self.frame_count = 0

        self.set_emulation_speed(1)
        self.paused = False
        self.events = []
        self.old_events = []
        self.quitting = False
        self.stopped = False
        self.window_title = &#34;PyBoy&#34;

        ###################
        # Plugins

        self.plugin_manager = PluginManager(self, self.mb, kwargs)
        self.initialized = True

    def tick(self):
        &#34;&#34;&#34;
        Progresses the emulator ahead by one frame.

        To run the emulator in real-time, this will need to be called 60 times a second (for example in a while-loop).
        This function will block for roughly 16,67ms at a time, to not run faster than real-time, unless you specify
        otherwise with the `PyBoy.set_emulation_speed` method.

        _Open an issue on GitHub if you need finer control, and we will take a look at it._
        &#34;&#34;&#34;
        if self.stopped:
            return True

        t_start = time.perf_counter_ns()
        self._handle_events(self.events)
        t_pre = time.perf_counter_ns()
        if not self.paused:
            if self.mb.tick():
                # breakpoint reached
                self.plugin_manager.handle_breakpoint()
            else:
                self.frame_count += 1
        t_tick = time.perf_counter_ns()
        self._post_tick()
        t_post = time.perf_counter_ns()

        nsecs = t_pre - t_start
        self.avg_pre = 0.9 * self.avg_pre + (0.1*nsecs/1_000_000_000)

        nsecs = t_tick - t_pre
        self.avg_tick = 0.9 * self.avg_tick + (0.1*nsecs/1_000_000_000)

        nsecs = t_post - t_tick
        self.avg_post = 0.9 * self.avg_post + (0.1*nsecs/1_000_000_000)

        return self.quitting

    def _handle_events(self, events):
        # This feeds events into the tick-loop from the window. There might already be events in the list from the API.
        events = self.plugin_manager.handle_events(events)
        for event in events:
            if event == WindowEvent.QUIT:
                self.quitting = True
            elif event == WindowEvent.RELEASE_SPEED_UP:
                # Switch between unlimited and 1x real-time emulation speed
                self.target_emulationspeed = int(bool(self.target_emulationspeed) ^ True)
                logger.info(&#34;Speed limit: %s&#34; % self.target_emulationspeed)
            elif event == WindowEvent.STATE_SAVE:
                with open(self.gamerom_file + &#34;.state&#34;, &#34;wb&#34;) as f:
                    self.mb.save_state(IntIOWrapper(f))
            elif event == WindowEvent.STATE_LOAD:
                state_path = self.gamerom_file + &#34;.state&#34;
                if not os.path.isfile(state_path):
                    logger.error(f&#34;State file not found: {state_path}&#34;)
                    continue
                with open(state_path, &#34;rb&#34;) as f:
                    self.mb.load_state(IntIOWrapper(f))
            elif event == WindowEvent.PASS:
                pass # Used in place of None in Cython, when key isn&#39;t mapped to anything
            elif event == WindowEvent.PAUSE_TOGGLE:
                if self.paused:
                    self._unpause()
                else:
                    self._pause()
            elif event == WindowEvent.PAUSE:
                self._pause()
            elif event == WindowEvent.UNPAUSE:
                self._unpause()
            elif event == WindowEvent._INTERNAL_RENDERER_FLUSH:
                self.plugin_manager._post_tick_windows()
            else:
                self.mb.buttonevent(event)

    def _pause(self):
        if self.paused:
            return
        self.paused = True
        self.save_target_emulationspeed = self.target_emulationspeed
        self.target_emulationspeed = 1
        logger.info(&#34;Emulation paused!&#34;)
        self._update_window_title()

    def _unpause(self):
        if not self.paused:
            return
        self.paused = False
        self.target_emulationspeed = self.save_target_emulationspeed
        logger.info(&#34;Emulation unpaused!&#34;)
        self._update_window_title()

    def _post_tick(self):
        if self.frame_count % 60 == 0:
            self._update_window_title()
        self.plugin_manager.post_tick()
        self.plugin_manager.frame_limiter(self.target_emulationspeed)

        # Prepare an empty list, as the API might be used to send in events between ticks
        self.old_events = self.events
        self.events = []

    def _update_window_title(self):
        avg_emu = self.avg_pre + self.avg_tick + self.avg_post
        self.window_title = &#34;CPU/frame: %0.2f%%&#34; % ((self.avg_pre + self.avg_tick) / SPF * 100)
        tolerance = 0.001 # 1ms. Avoid infinity and division by zero
        self.window_title += &#34; Emulation: x%s&#34; % (round(SPF / avg_emu) if avg_emu &gt; tolerance else &#34;INF&#34;)
        if self.paused:
            self.window_title += &#34;[PAUSED]&#34;
        self.window_title += self.plugin_manager.window_title()
        self.plugin_manager._set_title()

    def __del__(self):
        self.stop(save=False)

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.stop()

    def stop(self, save=True):
        &#34;&#34;&#34;
        Gently stops the emulator and all sub-modules.

        Args:
            save (bool): Specify whether to save the game upon stopping. It will always be saved in a file next to the
                provided game-ROM.
        &#34;&#34;&#34;
        if self.initialized and not self.stopped:
            logger.info(&#34;###########################&#34;)
            logger.info(&#34;# Emulator is turning off #&#34;)
            logger.info(&#34;###########################&#34;)
            self.plugin_manager.stop()
            self.mb.stop(save)
            self.stopped = True

    def _cpu_hitrate(self):
        return self.mb.cpu.hitrate

    ###################################################################
    # Scripts and bot methods
    #

    def botsupport_manager(self):
        &#34;&#34;&#34;

        Returns
        -------
        `pyboy.botsupport.BotSupportManager`:
            The manager, which gives easier access to the emulated game through the classes in `pyboy.botsupport`.
        &#34;&#34;&#34;
        return botsupport.BotSupportManager(self, self.mb)

    def openai_gym(self, observation_type=&#34;tiles&#34;, action_type=&#34;press&#34;, simultaneous_actions=False, **kwargs):
        &#34;&#34;&#34;
        For Reinforcement learning, it is often easier to use the standard gym environment. This method will provide one.
        This function requires PyBoy to implement a Game Wrapper for the loaded ROM. You can find the supported games in pyboy.plugins.
        Additional kwargs are passed to the start_game method of the game_wrapper.

        Args:
            observation_type (str): Define what the agent will be able to see:
            * `&#34;raw&#34;`: Gives the raw pixels color
            * `&#34;tiles&#34;`:  Gives the id of the sprites in 8x8 pixel zones of the game_area defined by the game_wrapper.
            * `&#34;compressed&#34;`: Gives a more detailled but heavier representation than `&#34;minimal&#34;`.
            * `&#34;minimal&#34;`: Gives a minimal representation defined by the game_wrapper (recommended).

            action_type (str): Define how the agent will interact with button inputs
            * `&#34;press&#34;`: The agent will only press inputs for 1 frame an then release it.
            * `&#34;toggle&#34;`: The agent will toggle inputs, first time it press and second time it release.
            * `&#34;all&#34;`: The agent have access to all inputs, press and release are separated.

            simultaneous_actions (bool): Allow to inject multiple input at once. This dramatically increases the action_space: \\(n \\rightarrow 2^n\\)

        Returns
        -------
        `pyboy.openai_gym.PyBoyGymEnv`:
            A Gym environment based on the `Pyboy` object.
        &#34;&#34;&#34;
        if gym_enabled:
            return PyBoyGymEnv(self, observation_type, action_type, simultaneous_actions, **kwargs)
        else:
            logger.error(f&#34;{__name__}: Missing dependency \&#34;gym\&#34;. &#34;)
            return None

    def game_wrapper(self):
        &#34;&#34;&#34;
        Provides an instance of a game-specific wrapper. The game is detected by the cartridge&#39;s hard-coded game title
        (see `pyboy.PyBoy.cartridge_title`).

        If the game isn&#39;t supported, None will be returned.

        To get more information, find the wrapper for your game in `pyboy.plugins`.

        Returns
        -------
        `pyboy.plugins.base_plugin.PyBoyGameWrapper`:
            A game-specific wrapper object.
        &#34;&#34;&#34;
        return self.plugin_manager.gamewrapper()

    def get_memory_value(self, addr):
        &#34;&#34;&#34;
        Reads a given memory address of the Game Boy&#39;s current memory state. This will not directly give you access to
        all switchable memory banks. Open an issue on GitHub if that is needed, or use `PyBoy.set_memory_value` to send
        MBC commands to the virtual cartridge.

        Returns
        -------
        int:
            An integer with the value of the memory address
        &#34;&#34;&#34;
        return self.mb.getitem(addr)

    def set_memory_value(self, addr, value):
        &#34;&#34;&#34;
        Write one byte to a given memory address of the Game Boy&#39;s current memory state.

        This will not directly give you access to all switchable memory banks.

        __NOTE:__ This function will not let you change ROM addresses (0x0000 to 0x8000). If you write to these
        addresses, it will send commands to the &#34;Memory Bank Controller&#34; (MBC) of the virtual cartridge. You can read
        about the MBC at [Pan Docs](http://bgb.bircd.org/pandocs.htm).

        If you need to change ROM values, see `pyboy.PyBoy.override_memory_value`.

        Args:
            addr (int): Address to write the byte
            value (int): A byte of data
        &#34;&#34;&#34;
        self.mb.setitem(addr, value)

    def override_memory_value(self, rom_bank, addr, value):
        &#34;&#34;&#34;
        Override one byte at a given memory address of the Game Boy&#39;s ROM.

        This will let you override data in the ROM at any given bank. This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000 can be changed from the MBC.

        __NOTE__: Any changes here are not saved or loaded to game states! Use this function with caution and reapply
        any overrides when reloading the ROM.

        If you need to change a RAM address, see `pyboy.PyBoy.set_memory_value`.

        Args:
            rom_bank (int): ROM bank to do the overwrite in
            addr (int): Address to write the byte inside the ROM bank
            value (int): A byte of data
        &#34;&#34;&#34;
        # TODO: If you change a RAM value outside of the ROM banks above, the memory value will stay the same no matter
        # what the game writes to the address. This can be used so freeze the value for health, cash etc.
        self.mb.cartridge.overrideitem(rom_bank, addr, value)

    def send_input(self, event):
        &#34;&#34;&#34;
        Send a single input to control the emulator. This is both Game Boy buttons and emulator controls.

        See `pyboy.WindowEvent` for which events to send.

        Args:
            event (pyboy.WindowEvent): The event to send
        &#34;&#34;&#34;
        self.events.append(WindowEvent(event))

    def get_input(
        self,
        ignore=(
            WindowEvent.PASS, WindowEvent._INTERNAL_TOGGLE_DEBUG, WindowEvent._INTERNAL_RENDERER_FLUSH,
            WindowEvent._INTERNAL_MOUSE, WindowEvent._INTERNAL_MARK_TILE
        )
    ):
        &#34;&#34;&#34;
        Get current inputs except the events specified in &#34;ignore&#34; tuple.
        This is both Game Boy buttons and emulator controls.

        See `pyboy.WindowEvent` for which events to get.

        Args:
            ignore (tuple): Events this function should ignore

        Returns
        -------
        list:
            List of the `pyboy.utils.WindowEvent`s processed for the last call to `pyboy.PyBoy.tick`
        &#34;&#34;&#34;
        return [x for x in self.old_events if x not in ignore]

    def save_state(self, file_like_object):
        &#34;&#34;&#34;
        Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
        a game.

        You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
        case. Remember to `seek` the in-memory buffer to the beginning before calling `PyBoy.load_state`:

            # Save to file
            file_like_object = open(&#34;state_file.state&#34;, &#34;wb&#34;)

            # Save to memory
            import io
            file_like_object = io.BytesIO()
            file_like_object.seek(0)

        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to write the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        self.mb.save_state(IntIOWrapper(file_like_object))

    def load_state(self, file_like_object):
        &#34;&#34;&#34;
        Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
        in a game.

        You can either load it from a file, or from memory. See `PyBoy.save_state` for how to save the state, before you
        can load it here.

        To load a file, remember to load it as bytes:

            # Load file
            file_like_object = open(&#34;state_file.state&#34;, &#34;rb&#34;)


        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to read the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        self.mb.load_state(IntIOWrapper(file_like_object))

    def screen_image(self):
        &#34;&#34;&#34;
        Shortcut for `pyboy.botsupport_manager.screen.screen_image`.

        Generates a PIL Image from the screen buffer.

        Convenient for screen captures, but might be a bottleneck, if you use it to train a neural network. In which
        case, read up on the `pyboy.botsupport` features, [Pan Docs](http://bgb.bircd.org/pandocs.htm) on tiles/sprites,
        and join our Discord channel for more help.

        Returns
        -------
        PIL.Image:
            RGB image of (160, 144) pixels
        &#34;&#34;&#34;
        return self.botsupport_manager().screen().screen_image()

    def _serial(self):
        &#34;&#34;&#34;
        Provides all data that has been sent over the serial port since last call to this function.

        Returns
        -------
        str :
            Buffer data
        &#34;&#34;&#34;
        return self.mb.getserial()

    def set_emulation_speed(self, target_speed):
        &#34;&#34;&#34;
        Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
        `target_speed`.

        The speed is defined as a multiple of real-time. I.e `target_speed=2` is double speed.

        A `target_speed` of `0` means unlimited. I.e. fastest possible execution.

        Some window types do not implement a frame-limiter, and will always run at full speed.

        Args:
            target_speed (int): Target emulation speed as multiplier of real-time.
        &#34;&#34;&#34;
        if target_speed &gt; 5:
            logger.warning(&#34;The emulation speed might not be accurate when speed-target is higher than 5&#34;)
        self.target_emulationspeed = target_speed

    def cartridge_title(self):
        &#34;&#34;&#34;
        Get the title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
        have been truncated to 11 characters.

        Returns
        -------
        str :
            Game title
        &#34;&#34;&#34;
        return self.mb.cartridge.gamename

    def _rendering(self, value):
        &#34;&#34;&#34;
        Disable or enable rendering
        &#34;&#34;&#34;
        self.mb.lcd.disable_renderer = not value

    def _is_cpu_stuck(self):
        return self.mb.cpu.is_stuck</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyboy.PyBoy.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Progresses the emulator ahead by one frame.</p>
<p>To run the emulator in real-time, this will need to be called 60 times a second (for example in a while-loop).
This function will block for roughly 16,67ms at a time, to not run faster than real-time, unless you specify
otherwise with the <code><a title="pyboy.PyBoy.set_emulation_speed" href="#pyboy.PyBoy.set_emulation_speed">PyBoy.set_emulation_speed()</a></code> method.</p>
<p><em>Open an issue on GitHub if you need finer control, and we will take a look at it.</em></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self):
    &#34;&#34;&#34;
    Progresses the emulator ahead by one frame.

    To run the emulator in real-time, this will need to be called 60 times a second (for example in a while-loop).
    This function will block for roughly 16,67ms at a time, to not run faster than real-time, unless you specify
    otherwise with the `PyBoy.set_emulation_speed` method.

    _Open an issue on GitHub if you need finer control, and we will take a look at it._
    &#34;&#34;&#34;
    if self.stopped:
        return True

    t_start = time.perf_counter_ns()
    self._handle_events(self.events)
    t_pre = time.perf_counter_ns()
    if not self.paused:
        if self.mb.tick():
            # breakpoint reached
            self.plugin_manager.handle_breakpoint()
        else:
            self.frame_count += 1
    t_tick = time.perf_counter_ns()
    self._post_tick()
    t_post = time.perf_counter_ns()

    nsecs = t_pre - t_start
    self.avg_pre = 0.9 * self.avg_pre + (0.1*nsecs/1_000_000_000)

    nsecs = t_tick - t_pre
    self.avg_tick = 0.9 * self.avg_tick + (0.1*nsecs/1_000_000_000)

    nsecs = t_post - t_tick
    self.avg_post = 0.9 * self.avg_post + (0.1*nsecs/1_000_000_000)

    return self.quitting</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, save=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Gently stops the emulator and all sub-modules.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code></dt>
<dd>Specify whether to save the game upon stopping. It will always be saved in a file next to the
provided game-ROM.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self, save=True):
    &#34;&#34;&#34;
    Gently stops the emulator and all sub-modules.

    Args:
        save (bool): Specify whether to save the game upon stopping. It will always be saved in a file next to the
            provided game-ROM.
    &#34;&#34;&#34;
    if self.initialized and not self.stopped:
        logger.info(&#34;###########################&#34;)
        logger.info(&#34;# Emulator is turning off #&#34;)
        logger.info(&#34;###########################&#34;)
        self.plugin_manager.stop()
        self.mb.stop(save)
        self.stopped = True</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.botsupport_manager"><code class="name flex">
<span>def <span class="ident">botsupport_manager</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p><code><a title="pyboy.botsupport.BotSupportManager" href="botsupport/index.html#pyboy.botsupport.BotSupportManager">BotSupportManager</a></code>:
The manager, which gives easier access to the emulated game through the classes in <code><a title="pyboy.botsupport" href="botsupport/index.html">pyboy.botsupport</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def botsupport_manager(self):
    &#34;&#34;&#34;

    Returns
    -------
    `pyboy.botsupport.BotSupportManager`:
        The manager, which gives easier access to the emulated game through the classes in `pyboy.botsupport`.
    &#34;&#34;&#34;
    return botsupport.BotSupportManager(self, self.mb)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.openai_gym"><code class="name flex">
<span>def <span class="ident">openai_gym</span></span>(<span>self, observation_type='tiles', action_type='press', simultaneous_actions=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>For Reinforcement learning, it is often easier to use the standard gym environment. This method will provide one.
This function requires PyBoy to implement a Game Wrapper for the loaded ROM. You can find the supported games in pyboy.plugins.
Additional kwargs are passed to the start_game method of the game_wrapper.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>observation_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Define what the agent will be able to see:</dd>
</dl>
<ul>
<li><code>"raw"</code>: Gives the raw pixels color</li>
<li><code>"tiles"</code>:
Gives the id of the sprites in 8x8 pixel zones of the game_area defined by the game_wrapper.</li>
<li><code>"compressed"</code>: Gives a more detailled but heavier representation than <code>"minimal"</code>.</li>
<li><code>"minimal"</code>: Gives a minimal representation defined by the game_wrapper (recommended).</li>
</ul>
<dl>
<dt><strong><code>action_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Define how the agent will interact with button inputs</dd>
</dl>
<ul>
<li><code>"press"</code>: The agent will only press inputs for 1 frame an then release it.</li>
<li><code>"toggle"</code>: The agent will toggle inputs, first time it press and second time it release.</li>
<li><code>"all"</code>: The agent have access to all inputs, press and release are separated.</li>
</ul>
<dl>
<dt><strong><code>simultaneous_actions</code></strong> :&ensp;<code>bool</code></dt>
<dd>Allow to inject multiple input at once. This dramatically increases the action_space: <span><span class="MathJax_Preview">n \rightarrow 2^n</span><script type="math/tex">n \rightarrow 2^n</script></span></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.openai_gym.PyBoyGymEnv" href="openai_gym.html#pyboy.openai_gym.PyBoyGymEnv">PyBoyGymEnv</a></code>:
A Gym environment based on the <code>Pyboy</code> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openai_gym(self, observation_type=&#34;tiles&#34;, action_type=&#34;press&#34;, simultaneous_actions=False, **kwargs):
    &#34;&#34;&#34;
    For Reinforcement learning, it is often easier to use the standard gym environment. This method will provide one.
    This function requires PyBoy to implement a Game Wrapper for the loaded ROM. You can find the supported games in pyboy.plugins.
    Additional kwargs are passed to the start_game method of the game_wrapper.

    Args:
        observation_type (str): Define what the agent will be able to see:
        * `&#34;raw&#34;`: Gives the raw pixels color
        * `&#34;tiles&#34;`:  Gives the id of the sprites in 8x8 pixel zones of the game_area defined by the game_wrapper.
        * `&#34;compressed&#34;`: Gives a more detailled but heavier representation than `&#34;minimal&#34;`.
        * `&#34;minimal&#34;`: Gives a minimal representation defined by the game_wrapper (recommended).

        action_type (str): Define how the agent will interact with button inputs
        * `&#34;press&#34;`: The agent will only press inputs for 1 frame an then release it.
        * `&#34;toggle&#34;`: The agent will toggle inputs, first time it press and second time it release.
        * `&#34;all&#34;`: The agent have access to all inputs, press and release are separated.

        simultaneous_actions (bool): Allow to inject multiple input at once. This dramatically increases the action_space: \\(n \\rightarrow 2^n\\)

    Returns
    -------
    `pyboy.openai_gym.PyBoyGymEnv`:
        A Gym environment based on the `Pyboy` object.
    &#34;&#34;&#34;
    if gym_enabled:
        return PyBoyGymEnv(self, observation_type, action_type, simultaneous_actions, **kwargs)
    else:
        logger.error(f&#34;{__name__}: Missing dependency \&#34;gym\&#34;. &#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.game_wrapper"><code class="name flex">
<span>def <span class="ident">game_wrapper</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides an instance of a game-specific wrapper. The game is detected by the cartridge's hard-coded game title
(see <code><a title="pyboy.PyBoy.cartridge_title" href="#pyboy.PyBoy.cartridge_title">PyBoy.cartridge_title()</a></code>).</p>
<p>If the game isn't supported, None will be returned.</p>
<p>To get more information, find the wrapper for your game in <code><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.plugins.base_plugin.PyBoyGameWrapper" href="plugins/base_plugin.html#pyboy.plugins.base_plugin.PyBoyGameWrapper">PyBoyGameWrapper</a></code>:
A game-specific wrapper object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def game_wrapper(self):
    &#34;&#34;&#34;
    Provides an instance of a game-specific wrapper. The game is detected by the cartridge&#39;s hard-coded game title
    (see `pyboy.PyBoy.cartridge_title`).

    If the game isn&#39;t supported, None will be returned.

    To get more information, find the wrapper for your game in `pyboy.plugins`.

    Returns
    -------
    `pyboy.plugins.base_plugin.PyBoyGameWrapper`:
        A game-specific wrapper object.
    &#34;&#34;&#34;
    return self.plugin_manager.gamewrapper()</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.get_memory_value"><code class="name flex">
<span>def <span class="ident">get_memory_value</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads a given memory address of the Game Boy's current memory state. This will not directly give you access to
all switchable memory banks. Open an issue on GitHub if that is needed, or use <code><a title="pyboy.PyBoy.set_memory_value" href="#pyboy.PyBoy.set_memory_value">PyBoy.set_memory_value()</a></code> to send
MBC commands to the virtual cartridge.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>An integer with the value of the memory address</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_memory_value(self, addr):
    &#34;&#34;&#34;
    Reads a given memory address of the Game Boy&#39;s current memory state. This will not directly give you access to
    all switchable memory banks. Open an issue on GitHub if that is needed, or use `PyBoy.set_memory_value` to send
    MBC commands to the virtual cartridge.

    Returns
    -------
    int:
        An integer with the value of the memory address
    &#34;&#34;&#34;
    return self.mb.getitem(addr)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.set_memory_value"><code class="name flex">
<span>def <span class="ident">set_memory_value</span></span>(<span>self, addr, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Write one byte to a given memory address of the Game Boy's current memory state.</p>
<p>This will not directly give you access to all switchable memory banks.</p>
<p><strong>NOTE:</strong> This function will not let you change ROM addresses (0x0000 to 0x8000). If you write to these
addresses, it will send commands to the "Memory Bank Controller" (MBC) of the virtual cartridge. You can read
about the MBC at <a href="http://bgb.bircd.org/pandocs.htm">Pan Docs</a>.</p>
<p>If you need to change ROM values, see <code><a title="pyboy.PyBoy.override_memory_value" href="#pyboy.PyBoy.override_memory_value">PyBoy.override_memory_value()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address to write the byte</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>A byte of data</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_memory_value(self, addr, value):
    &#34;&#34;&#34;
    Write one byte to a given memory address of the Game Boy&#39;s current memory state.

    This will not directly give you access to all switchable memory banks.

    __NOTE:__ This function will not let you change ROM addresses (0x0000 to 0x8000). If you write to these
    addresses, it will send commands to the &#34;Memory Bank Controller&#34; (MBC) of the virtual cartridge. You can read
    about the MBC at [Pan Docs](http://bgb.bircd.org/pandocs.htm).

    If you need to change ROM values, see `pyboy.PyBoy.override_memory_value`.

    Args:
        addr (int): Address to write the byte
        value (int): A byte of data
    &#34;&#34;&#34;
    self.mb.setitem(addr, value)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.override_memory_value"><code class="name flex">
<span>def <span class="ident">override_memory_value</span></span>(<span>self, rom_bank, addr, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Override one byte at a given memory address of the Game Boy's ROM.</p>
<p>This will let you override data in the ROM at any given bank. This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000 can be changed from the MBC.</p>
<p><strong>NOTE</strong>: Any changes here are not saved or loaded to game states! Use this function with caution and reapply
any overrides when reloading the ROM.</p>
<p>If you need to change a RAM address, see <code><a title="pyboy.PyBoy.set_memory_value" href="#pyboy.PyBoy.set_memory_value">PyBoy.set_memory_value()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rom_bank</code></strong> :&ensp;<code>int</code></dt>
<dd>ROM bank to do the overwrite in</dd>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address to write the byte inside the ROM bank</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>A byte of data</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_memory_value(self, rom_bank, addr, value):
    &#34;&#34;&#34;
    Override one byte at a given memory address of the Game Boy&#39;s ROM.

    This will let you override data in the ROM at any given bank. This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000 can be changed from the MBC.

    __NOTE__: Any changes here are not saved or loaded to game states! Use this function with caution and reapply
    any overrides when reloading the ROM.

    If you need to change a RAM address, see `pyboy.PyBoy.set_memory_value`.

    Args:
        rom_bank (int): ROM bank to do the overwrite in
        addr (int): Address to write the byte inside the ROM bank
        value (int): A byte of data
    &#34;&#34;&#34;
    # TODO: If you change a RAM value outside of the ROM banks above, the memory value will stay the same no matter
    # what the game writes to the address. This can be used so freeze the value for health, cash etc.
    self.mb.cartridge.overrideitem(rom_bank, addr, value)</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.send_input"><code class="name flex">
<span>def <span class="ident">send_input</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a single input to control the emulator. This is both Game Boy buttons and emulator controls.</p>
<p>See <code><a title="pyboy.WindowEvent" href="#pyboy.WindowEvent">WindowEvent</a></code> for which events to send.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code><a title="pyboy.WindowEvent" href="#pyboy.WindowEvent">WindowEvent</a></code></dt>
<dd>The event to send</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_input(self, event):
    &#34;&#34;&#34;
    Send a single input to control the emulator. This is both Game Boy buttons and emulator controls.

    See `pyboy.WindowEvent` for which events to send.

    Args:
        event (pyboy.WindowEvent): The event to send
    &#34;&#34;&#34;
    self.events.append(WindowEvent(event))</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.get_input"><code class="name flex">
<span>def <span class="ident">get_input</span></span>(<span>self, ignore=(22, 17, 33, 34, 35))</span>
</code></dt>
<dd>
<section class="desc"><p>Get current inputs except the events specified in "ignore" tuple.
This is both Game Boy buttons and emulator controls.</p>
<p>See <code><a title="pyboy.WindowEvent" href="#pyboy.WindowEvent">WindowEvent</a></code> for which events to get.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ignore</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Events this function should ignore</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list:</code></dt>
<dd>List of the <code>pyboy.utils.WindowEvent</code>s processed for the last call to <code><a title="pyboy.PyBoy.tick" href="#pyboy.PyBoy.tick">PyBoy.tick()</a></code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input(
    self,
    ignore=(
        WindowEvent.PASS, WindowEvent._INTERNAL_TOGGLE_DEBUG, WindowEvent._INTERNAL_RENDERER_FLUSH,
        WindowEvent._INTERNAL_MOUSE, WindowEvent._INTERNAL_MARK_TILE
    )
):
    &#34;&#34;&#34;
    Get current inputs except the events specified in &#34;ignore&#34; tuple.
    This is both Game Boy buttons and emulator controls.

    See `pyboy.WindowEvent` for which events to get.

    Args:
        ignore (tuple): Events this function should ignore

    Returns
    -------
    list:
        List of the `pyboy.utils.WindowEvent`s processed for the last call to `pyboy.PyBoy.tick`
    &#34;&#34;&#34;
    return [x for x in self.old_events if x not in ignore]</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.save_state"><code class="name flex">
<span>def <span class="ident">save_state</span></span>(<span>self, file_like_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
a game.</p>
<p>You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
case. Remember to <code>seek</code> the in-memory buffer to the beginning before calling <code><a title="pyboy.PyBoy.load_state" href="#pyboy.PyBoy.load_state">PyBoy.load_state()</a></code>:</p>
<pre><code># Save to file
file_like_object = open("state_file.state", "wb")

# Save to memory
import io
file_like_object = io.BytesIO()
file_like_object.seek(0)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :&ensp;<code>io.BufferedIOBase</code></dt>
<dd>A file-like object for which to write the emulator state.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_state(self, file_like_object):
    &#34;&#34;&#34;
    Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
    a game.

    You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
    case. Remember to `seek` the in-memory buffer to the beginning before calling `PyBoy.load_state`:

        # Save to file
        file_like_object = open(&#34;state_file.state&#34;, &#34;wb&#34;)

        # Save to memory
        import io
        file_like_object = io.BytesIO()
        file_like_object.seek(0)

    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which to write the emulator state.
    &#34;&#34;&#34;

    if isinstance(file_like_object, str):
        raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

    self.mb.save_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.load_state"><code class="name flex">
<span>def <span class="ident">load_state</span></span>(<span>self, file_like_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
in a game.</p>
<p>You can either load it from a file, or from memory. See <code><a title="pyboy.PyBoy.save_state" href="#pyboy.PyBoy.save_state">PyBoy.save_state()</a></code> for how to save the state, before you
can load it here.</p>
<p>To load a file, remember to load it as bytes:</p>
<pre><code># Load file
file_like_object = open("state_file.state", "rb")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :&ensp;<code>io.BufferedIOBase</code></dt>
<dd>A file-like object for which to read the emulator state.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_state(self, file_like_object):
    &#34;&#34;&#34;
    Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
    in a game.

    You can either load it from a file, or from memory. See `PyBoy.save_state` for how to save the state, before you
    can load it here.

    To load a file, remember to load it as bytes:

        # Load file
        file_like_object = open(&#34;state_file.state&#34;, &#34;rb&#34;)


    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which to read the emulator state.
    &#34;&#34;&#34;

    if isinstance(file_like_object, str):
        raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

    self.mb.load_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.screen_image"><code class="name flex">
<span>def <span class="ident">screen_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Shortcut for <code>pyboy.botsupport_manager.screen.screen_image</code>.</p>
<p>Generates a PIL Image from the screen buffer.</p>
<p>Convenient for screen captures, but might be a bottleneck, if you use it to train a neural network. In which
case, read up on the <code><a title="pyboy.botsupport" href="botsupport/index.html">pyboy.botsupport</a></code> features, <a href="http://bgb.bircd.org/pandocs.htm">Pan Docs</a> on tiles/sprites,
and join our Discord channel for more help.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image:</code></dt>
<dd>RGB image of (160, 144) pixels</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def screen_image(self):
    &#34;&#34;&#34;
    Shortcut for `pyboy.botsupport_manager.screen.screen_image`.

    Generates a PIL Image from the screen buffer.

    Convenient for screen captures, but might be a bottleneck, if you use it to train a neural network. In which
    case, read up on the `pyboy.botsupport` features, [Pan Docs](http://bgb.bircd.org/pandocs.htm) on tiles/sprites,
    and join our Discord channel for more help.

    Returns
    -------
    PIL.Image:
        RGB image of (160, 144) pixels
    &#34;&#34;&#34;
    return self.botsupport_manager().screen().screen_image()</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.set_emulation_speed"><code class="name flex">
<span>def <span class="ident">set_emulation_speed</span></span>(<span>self, target_speed)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
<code>target_speed</code>.</p>
<p>The speed is defined as a multiple of real-time. I.e <code>target_speed=2</code> is double speed.</p>
<p>A <code>target_speed</code> of <code>0</code> means unlimited. I.e. fastest possible execution.</p>
<p>Some window types do not implement a frame-limiter, and will always run at full speed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_speed</code></strong> :&ensp;<code>int</code></dt>
<dd>Target emulation speed as multiplier of real-time.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_emulation_speed(self, target_speed):
    &#34;&#34;&#34;
    Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
    `target_speed`.

    The speed is defined as a multiple of real-time. I.e `target_speed=2` is double speed.

    A `target_speed` of `0` means unlimited. I.e. fastest possible execution.

    Some window types do not implement a frame-limiter, and will always run at full speed.

    Args:
        target_speed (int): Target emulation speed as multiplier of real-time.
    &#34;&#34;&#34;
    if target_speed &gt; 5:
        logger.warning(&#34;The emulation speed might not be accurate when speed-target is higher than 5&#34;)
    self.target_emulationspeed = target_speed</code></pre>
</details>
</dd>
<dt id="pyboy.PyBoy.cartridge_title"><code class="name flex">
<span>def <span class="ident">cartridge_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
have been truncated to 11 characters.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str :</code></dt>
<dd>Game title</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cartridge_title(self):
    &#34;&#34;&#34;
    Get the title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
    have been truncated to 11 characters.

    Returns
    -------
    str :
        Game title
    &#34;&#34;&#34;
    return self.mb.cartridge.gamename</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.WindowEvent"><code class="flex name class">
<span>class <span class="ident">WindowEvent</span></span>
<span>(</span><span>event)</span>
</code></dt>
<dd>
<section class="desc"><p>All supported events can be found in the class description below.</p>
<p>It can be used as follows:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pyboy import PyBoy, WindowEvent
&gt;&gt;&gt; pyboy = PyBoy('file.rom')
&gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_ARROW_RIGHT)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WindowEvent:
    &#34;&#34;&#34;
    All supported events can be found in the class description below.

    It can be used as follows:

    &gt;&gt;&gt; from pyboy import PyBoy, WindowEvent
    &gt;&gt;&gt; pyboy = PyBoy(&#39;file.rom&#39;)
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_ARROW_RIGHT)
    &#34;&#34;&#34;

    # ONLY ADD NEW EVENTS AT THE END OF THE LIST!
    # Otherwise, it will break replays, which depend on the id of the event
    (
        QUIT,
        PRESS_ARROW_UP,
        PRESS_ARROW_DOWN,
        PRESS_ARROW_RIGHT,
        PRESS_ARROW_LEFT,
        PRESS_BUTTON_A,
        PRESS_BUTTON_B,
        PRESS_BUTTON_SELECT,
        PRESS_BUTTON_START,
        RELEASE_ARROW_UP,
        RELEASE_ARROW_DOWN,
        RELEASE_ARROW_RIGHT,
        RELEASE_ARROW_LEFT,
        RELEASE_BUTTON_A,
        RELEASE_BUTTON_B,
        RELEASE_BUTTON_SELECT,
        RELEASE_BUTTON_START,
        _INTERNAL_TOGGLE_DEBUG,
        PRESS_SPEED_UP,
        RELEASE_SPEED_UP,
        STATE_SAVE,
        STATE_LOAD,
        PASS,
        SCREEN_RECORDING_TOGGLE,
        PAUSE,
        UNPAUSE,
        PAUSE_TOGGLE,
        PRESS_REWIND_BACK,
        PRESS_REWIND_FORWARD,
        RELEASE_REWIND_BACK,
        RELEASE_REWIND_FORWARD,
        WINDOW_FOCUS,
        WINDOW_UNFOCUS,
        _INTERNAL_RENDERER_FLUSH,
        _INTERNAL_MOUSE,
        _INTERNAL_MARK_TILE,
        SCREENSHOT_RECORD,
        DEBUG_MEMORY_SCROLL_DOWN,
        DEBUG_MEMORY_SCROLL_UP,
        MOD_SHIFT_ON,
        MOD_SHIFT_OFF,
        FULL_SCREEN_TOGGLE,
    ) = range(42)

    def __init__(self, event):
        self.event = event

    def __eq__(self, x):
        if isinstance(x, int):
            return self.event == x
        else:
            return self.event == x.event

    def __int__(self):
        return self.event

    def __str__(self):
        return (
            &#34;QUIT&#34;,
            &#34;PRESS_ARROW_UP&#34;,
            &#34;PRESS_ARROW_DOWN&#34;,
            &#34;PRESS_ARROW_RIGHT&#34;,
            &#34;PRESS_ARROW_LEFT&#34;,
            &#34;PRESS_BUTTON_A&#34;,
            &#34;PRESS_BUTTON_B&#34;,
            &#34;PRESS_BUTTON_SELECT&#34;,
            &#34;PRESS_BUTTON_START&#34;,
            &#34;RELEASE_ARROW_UP&#34;,
            &#34;RELEASE_ARROW_DOWN&#34;,
            &#34;RELEASE_ARROW_RIGHT&#34;,
            &#34;RELEASE_ARROW_LEFT&#34;,
            &#34;RELEASE_BUTTON_A&#34;,
            &#34;RELEASE_BUTTON_B&#34;,
            &#34;RELEASE_BUTTON_SELECT&#34;,
            &#34;RELEASE_BUTTON_START&#34;,
            &#34;_INTERNAL_TOGGLE_DEBUG&#34;,
            &#34;PRESS_SPEED_UP&#34;,
            &#34;RELEASE_SPEED_UP&#34;,
            &#34;STATE_SAVE&#34;,
            &#34;STATE_LOAD&#34;,
            &#34;PASS&#34;,
            &#34;SCREEN_RECORDING_TOGGLE&#34;,
            &#34;PAUSE&#34;,
            &#34;UNPAUSE&#34;,
            &#34;PAUSE_TOGGLE&#34;,
            &#34;PRESS_REWIND_BACK&#34;,
            &#34;PRESS_REWIND_FORWARD&#34;,
            &#34;RELEASE_REWIND_BACK&#34;,
            &#34;RELEASE_REWIND_FORWARD&#34;,
            &#34;WINDOW_FOCUS&#34;,
            &#34;WINDOW_UNFOCUS&#34;,
            &#34;_INTERNAL_RENDERER_FLUSH&#34;,
            &#34;_INTERNAL_MOUSE&#34;,
            &#34;_INTERNAL_MARK_TILE&#34;,
            &#34;SCREENSHOT_RECORD&#34;,
            &#34;DEBUG_MEMORY_SCROLL_DOWN&#34;,
            &#34;DEBUG_MEMORY_SCROLL_UP&#34;,
            &#34;MOD_SHIFT_ON&#34;,
            &#34;MOD_SHIFT_OFF&#34;,
            &#34;FULL_SCREEN_TOGGLE&#34;,
        )[self.event]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyboy.utils.WindowEventMouse</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyboy.WindowEvent.QUIT"><code class="name">var <span class="ident">QUIT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_ARROW_UP"><code class="name">var <span class="ident">PRESS_ARROW_UP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_ARROW_DOWN"><code class="name">var <span class="ident">PRESS_ARROW_DOWN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_ARROW_RIGHT"><code class="name">var <span class="ident">PRESS_ARROW_RIGHT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_ARROW_LEFT"><code class="name">var <span class="ident">PRESS_ARROW_LEFT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_BUTTON_A"><code class="name">var <span class="ident">PRESS_BUTTON_A</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_BUTTON_B"><code class="name">var <span class="ident">PRESS_BUTTON_B</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_BUTTON_SELECT"><code class="name">var <span class="ident">PRESS_BUTTON_SELECT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_BUTTON_START"><code class="name">var <span class="ident">PRESS_BUTTON_START</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_ARROW_UP"><code class="name">var <span class="ident">RELEASE_ARROW_UP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_ARROW_DOWN"><code class="name">var <span class="ident">RELEASE_ARROW_DOWN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_ARROW_RIGHT"><code class="name">var <span class="ident">RELEASE_ARROW_RIGHT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_ARROW_LEFT"><code class="name">var <span class="ident">RELEASE_ARROW_LEFT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_BUTTON_A"><code class="name">var <span class="ident">RELEASE_BUTTON_A</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_BUTTON_B"><code class="name">var <span class="ident">RELEASE_BUTTON_B</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_BUTTON_SELECT"><code class="name">var <span class="ident">RELEASE_BUTTON_SELECT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_BUTTON_START"><code class="name">var <span class="ident">RELEASE_BUTTON_START</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_SPEED_UP"><code class="name">var <span class="ident">PRESS_SPEED_UP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_SPEED_UP"><code class="name">var <span class="ident">RELEASE_SPEED_UP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.STATE_SAVE"><code class="name">var <span class="ident">STATE_SAVE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.STATE_LOAD"><code class="name">var <span class="ident">STATE_LOAD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PASS"><code class="name">var <span class="ident">PASS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.SCREEN_RECORDING_TOGGLE"><code class="name">var <span class="ident">SCREEN_RECORDING_TOGGLE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PAUSE"><code class="name">var <span class="ident">PAUSE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.UNPAUSE"><code class="name">var <span class="ident">UNPAUSE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PAUSE_TOGGLE"><code class="name">var <span class="ident">PAUSE_TOGGLE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_REWIND_BACK"><code class="name">var <span class="ident">PRESS_REWIND_BACK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.PRESS_REWIND_FORWARD"><code class="name">var <span class="ident">PRESS_REWIND_FORWARD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_REWIND_BACK"><code class="name">var <span class="ident">RELEASE_REWIND_BACK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.RELEASE_REWIND_FORWARD"><code class="name">var <span class="ident">RELEASE_REWIND_FORWARD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.WINDOW_FOCUS"><code class="name">var <span class="ident">WINDOW_FOCUS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.WINDOW_UNFOCUS"><code class="name">var <span class="ident">WINDOW_UNFOCUS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.SCREENSHOT_RECORD"><code class="name">var <span class="ident">SCREENSHOT_RECORD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.DEBUG_MEMORY_SCROLL_DOWN"><code class="name">var <span class="ident">DEBUG_MEMORY_SCROLL_DOWN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.DEBUG_MEMORY_SCROLL_UP"><code class="name">var <span class="ident">DEBUG_MEMORY_SCROLL_UP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.MOD_SHIFT_ON"><code class="name">var <span class="ident">MOD_SHIFT_ON</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.MOD_SHIFT_OFF"><code class="name">var <span class="ident">MOD_SHIFT_OFF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pyboy.WindowEvent.FULL_SCREEN_TOGGLE"><code class="name">var <span class="ident">FULL_SCREEN_TOGGLE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyboy.botsupport" href="botsupport/index.html">pyboy.botsupport</a></code></li>
<li><code><a title="pyboy.openai_gym" href="openai_gym.html">pyboy.openai_gym</a></code></li>
<li><code><a title="pyboy.plugins" href="plugins/index.html">pyboy.plugins</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.PyBoy" href="#pyboy.PyBoy">PyBoy</a></code></h4>
<ul class="">
<li><code><a title="pyboy.PyBoy.tick" href="#pyboy.PyBoy.tick">tick</a></code></li>
<li><code><a title="pyboy.PyBoy.stop" href="#pyboy.PyBoy.stop">stop</a></code></li>
<li><code><a title="pyboy.PyBoy.botsupport_manager" href="#pyboy.PyBoy.botsupport_manager">botsupport_manager</a></code></li>
<li><code><a title="pyboy.PyBoy.openai_gym" href="#pyboy.PyBoy.openai_gym">openai_gym</a></code></li>
<li><code><a title="pyboy.PyBoy.game_wrapper" href="#pyboy.PyBoy.game_wrapper">game_wrapper</a></code></li>
<li><code><a title="pyboy.PyBoy.get_memory_value" href="#pyboy.PyBoy.get_memory_value">get_memory_value</a></code></li>
<li><code><a title="pyboy.PyBoy.set_memory_value" href="#pyboy.PyBoy.set_memory_value">set_memory_value</a></code></li>
<li><code><a title="pyboy.PyBoy.override_memory_value" href="#pyboy.PyBoy.override_memory_value">override_memory_value</a></code></li>
<li><code><a title="pyboy.PyBoy.send_input" href="#pyboy.PyBoy.send_input">send_input</a></code></li>
<li><code><a title="pyboy.PyBoy.get_input" href="#pyboy.PyBoy.get_input">get_input</a></code></li>
<li><code><a title="pyboy.PyBoy.save_state" href="#pyboy.PyBoy.save_state">save_state</a></code></li>
<li><code><a title="pyboy.PyBoy.load_state" href="#pyboy.PyBoy.load_state">load_state</a></code></li>
<li><code><a title="pyboy.PyBoy.screen_image" href="#pyboy.PyBoy.screen_image">screen_image</a></code></li>
<li><code><a title="pyboy.PyBoy.set_emulation_speed" href="#pyboy.PyBoy.set_emulation_speed">set_emulation_speed</a></code></li>
<li><code><a title="pyboy.PyBoy.cartridge_title" href="#pyboy.PyBoy.cartridge_title">cartridge_title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.WindowEvent" href="#pyboy.WindowEvent">WindowEvent</a></code></h4>
<ul class="">
<li><code><a title="pyboy.WindowEvent.QUIT" href="#pyboy.WindowEvent.QUIT">QUIT</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_ARROW_UP" href="#pyboy.WindowEvent.PRESS_ARROW_UP">PRESS_ARROW_UP</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_ARROW_DOWN" href="#pyboy.WindowEvent.PRESS_ARROW_DOWN">PRESS_ARROW_DOWN</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_ARROW_RIGHT" href="#pyboy.WindowEvent.PRESS_ARROW_RIGHT">PRESS_ARROW_RIGHT</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_ARROW_LEFT" href="#pyboy.WindowEvent.PRESS_ARROW_LEFT">PRESS_ARROW_LEFT</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_BUTTON_A" href="#pyboy.WindowEvent.PRESS_BUTTON_A">PRESS_BUTTON_A</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_BUTTON_B" href="#pyboy.WindowEvent.PRESS_BUTTON_B">PRESS_BUTTON_B</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_BUTTON_SELECT" href="#pyboy.WindowEvent.PRESS_BUTTON_SELECT">PRESS_BUTTON_SELECT</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_BUTTON_START" href="#pyboy.WindowEvent.PRESS_BUTTON_START">PRESS_BUTTON_START</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_ARROW_UP" href="#pyboy.WindowEvent.RELEASE_ARROW_UP">RELEASE_ARROW_UP</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_ARROW_DOWN" href="#pyboy.WindowEvent.RELEASE_ARROW_DOWN">RELEASE_ARROW_DOWN</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_ARROW_RIGHT" href="#pyboy.WindowEvent.RELEASE_ARROW_RIGHT">RELEASE_ARROW_RIGHT</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_ARROW_LEFT" href="#pyboy.WindowEvent.RELEASE_ARROW_LEFT">RELEASE_ARROW_LEFT</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_BUTTON_A" href="#pyboy.WindowEvent.RELEASE_BUTTON_A">RELEASE_BUTTON_A</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_BUTTON_B" href="#pyboy.WindowEvent.RELEASE_BUTTON_B">RELEASE_BUTTON_B</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_BUTTON_SELECT" href="#pyboy.WindowEvent.RELEASE_BUTTON_SELECT">RELEASE_BUTTON_SELECT</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_BUTTON_START" href="#pyboy.WindowEvent.RELEASE_BUTTON_START">RELEASE_BUTTON_START</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_SPEED_UP" href="#pyboy.WindowEvent.PRESS_SPEED_UP">PRESS_SPEED_UP</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_SPEED_UP" href="#pyboy.WindowEvent.RELEASE_SPEED_UP">RELEASE_SPEED_UP</a></code></li>
<li><code><a title="pyboy.WindowEvent.STATE_SAVE" href="#pyboy.WindowEvent.STATE_SAVE">STATE_SAVE</a></code></li>
<li><code><a title="pyboy.WindowEvent.STATE_LOAD" href="#pyboy.WindowEvent.STATE_LOAD">STATE_LOAD</a></code></li>
<li><code><a title="pyboy.WindowEvent.PASS" href="#pyboy.WindowEvent.PASS">PASS</a></code></li>
<li><code><a title="pyboy.WindowEvent.SCREEN_RECORDING_TOGGLE" href="#pyboy.WindowEvent.SCREEN_RECORDING_TOGGLE">SCREEN_RECORDING_TOGGLE</a></code></li>
<li><code><a title="pyboy.WindowEvent.PAUSE" href="#pyboy.WindowEvent.PAUSE">PAUSE</a></code></li>
<li><code><a title="pyboy.WindowEvent.UNPAUSE" href="#pyboy.WindowEvent.UNPAUSE">UNPAUSE</a></code></li>
<li><code><a title="pyboy.WindowEvent.PAUSE_TOGGLE" href="#pyboy.WindowEvent.PAUSE_TOGGLE">PAUSE_TOGGLE</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_REWIND_BACK" href="#pyboy.WindowEvent.PRESS_REWIND_BACK">PRESS_REWIND_BACK</a></code></li>
<li><code><a title="pyboy.WindowEvent.PRESS_REWIND_FORWARD" href="#pyboy.WindowEvent.PRESS_REWIND_FORWARD">PRESS_REWIND_FORWARD</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_REWIND_BACK" href="#pyboy.WindowEvent.RELEASE_REWIND_BACK">RELEASE_REWIND_BACK</a></code></li>
<li><code><a title="pyboy.WindowEvent.RELEASE_REWIND_FORWARD" href="#pyboy.WindowEvent.RELEASE_REWIND_FORWARD">RELEASE_REWIND_FORWARD</a></code></li>
<li><code><a title="pyboy.WindowEvent.WINDOW_FOCUS" href="#pyboy.WindowEvent.WINDOW_FOCUS">WINDOW_FOCUS</a></code></li>
<li><code><a title="pyboy.WindowEvent.WINDOW_UNFOCUS" href="#pyboy.WindowEvent.WINDOW_UNFOCUS">WINDOW_UNFOCUS</a></code></li>
<li><code><a title="pyboy.WindowEvent.SCREENSHOT_RECORD" href="#pyboy.WindowEvent.SCREENSHOT_RECORD">SCREENSHOT_RECORD</a></code></li>
<li><code><a title="pyboy.WindowEvent.DEBUG_MEMORY_SCROLL_DOWN" href="#pyboy.WindowEvent.DEBUG_MEMORY_SCROLL_DOWN">DEBUG_MEMORY_SCROLL_DOWN</a></code></li>
<li><code><a title="pyboy.WindowEvent.DEBUG_MEMORY_SCROLL_UP" href="#pyboy.WindowEvent.DEBUG_MEMORY_SCROLL_UP">DEBUG_MEMORY_SCROLL_UP</a></code></li>
<li><code><a title="pyboy.WindowEvent.MOD_SHIFT_ON" href="#pyboy.WindowEvent.MOD_SHIFT_ON">MOD_SHIFT_ON</a></code></li>
<li><code><a title="pyboy.WindowEvent.MOD_SHIFT_OFF" href="#pyboy.WindowEvent.MOD_SHIFT_OFF">MOD_SHIFT_OFF</a></code></li>
<li><code><a title="pyboy.WindowEvent.FULL_SCREEN_TOGGLE" href="#pyboy.WindowEvent.FULL_SCREEN_TOGGLE">FULL_SCREEN_TOGGLE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>