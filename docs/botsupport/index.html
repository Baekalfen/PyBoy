<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyboy.botsupport API documentation</title>
<meta name="description" content="Tools to help interfacing with the Game Boy hardware" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:0.8em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy.botsupport</code></h1>
</header>
<section id="section-intro">
<p>Tools to help interfacing with the Game Boy hardware</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# License: See LICENSE.md file
# GitHub: https://github.com/Baekalfen/PyBoy
#
&#34;&#34;&#34;
Tools to help interfacing with the Game Boy hardware
&#34;&#34;&#34;

__pdoc__ = {
    &#34;constants&#34;: False,
    &#34;manager&#34;: False,
}
__all__ = [&#34;BotSupportManager&#34;]

from .manager import BotSupportManager</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyboy.botsupport.screen" href="screen.html">pyboy.botsupport.screen</a></code></dt>
<dd>
<section class="desc"><p>This class gives access to the frame buffer and other screen parameters of PyBoy.</p></section>
</dd>
<dt><code class="name"><a title="pyboy.botsupport.sprite" href="sprite.html">pyboy.botsupport.sprite</a></code></dt>
<dd>
<section class="desc"><p>This class presents an interface to the sprites held in the OAM data on the Game Boy.</p></section>
</dd>
<dt><code class="name"><a title="pyboy.botsupport.tile" href="tile.html">pyboy.botsupport.tile</a></code></dt>
<dd>
<section class="desc"><p>The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used both for
<code><a title="pyboy.botsupport.sprite.Sprite" href="sprite.html#pyboy.botsupport.sprite.Sprite">Sprite</a></code> and â€¦</p></section>
</dd>
<dt><code class="name"><a title="pyboy.botsupport.tilemap" href="tilemap.html">pyboy.botsupport.tilemap</a></code></dt>
<dd>
<section class="desc"><p>The Game Boy has two tile maps, which defines what is rendered on the screen.</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.botsupport.BotSupportManager"><code class="flex name class">
<span>class <span class="ident">BotSupportManager</span></span>
<span>(</span><span>pyboy, mb)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BotSupportManager:
    def __init__(self, pyboy, mb):
        if not cythonmode:
            self.pyboy = pyboy
            self.mb = mb

    def __cinit__(self, pyboy, mb):
        self.pyboy = pyboy
        self.mb = mb

    def screen(self):
        &#34;&#34;&#34;
        Use this method to get a `pyboy.botsupport.screen.Screen` object. This can be used to get the screen buffer in
        a variety of formats.

        It&#39;s also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
        `pyboy.botsupport.screen.Screen.tilemap_position` for more information.

        Returns
        -------
        `pyboy.botsupport.screen.Screen`:
            A Screen object with helper functions for reading the screen buffer.
        &#34;&#34;&#34;
        return _screen.Screen(self.mb)

    def sprite(self, sprite_index):
        &#34;&#34;&#34;
        Provides a `pyboy.botsupport.sprite.Sprite` object, which makes the OAM data more presentable. The given index
        corresponds to index of the sprite in the &#34;Object Attribute Memory&#34; (OAM).

        The Game Boy supports 40 sprites in total. Read more details about it, in the [Pan
        Docs](http://bgb.bircd.org/pandocs.htm).

        Args:
            index (int): Sprite index from 0 to 39.
        Returns
        -------
        `pyboy.botsupport.sprite.Sprite`:
            Sprite corresponding to the given index.
        &#34;&#34;&#34;
        return _sprite.Sprite(self.mb, sprite_index)

    def sprite_by_tile_identifier(self, tile_identifiers, on_screen=True):
        &#34;&#34;&#34;
        Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
        identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
        `pyboy.botsupport.BotSupportManager.sprite` function to get a `pyboy.botsupport.sprite.Sprite` object.

        Example:
        ```
        &gt;&gt;&gt; print(pyboy.botsupport_manager().sprite_by_tile_identifier([43, 123]))
        [[0, 2, 4], []]
        ```

        Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2, and 4, while tile identifier
        `123` was not found anywhere.

        Args:
            identifiers (list): List of tile identifiers (int)
            on_screen (bool): Require that the matched sprite is on screen

        Returns
        -------
        list:
            list of sprite matches for every tile identifier in the input
        &#34;&#34;&#34;

        matches = []
        for i in tile_identifiers:
            match = []
            for s in range(_constants.SPRITES):
                sprite = _sprite.Sprite(self.mb, s)
                for t in sprite.tiles:
                    if t.tile_identifier == i and (not on_screen or (on_screen and sprite.on_screen)):
                        match.append(s)
            matches.append(match)
        return matches

    def tile(self, identifier):
        &#34;&#34;&#34;
        The Game Boy can have 384 tiles loaded in memory at once. Use this method to get a
        `pyboy.botsupport.tile.Tile`-object for given identifier.

        The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
        the `pyboy.botsupport.tile.Tile` object for more information.

        Returns
        -------
        `pyboy.botsupport.tile.Tile`:
            A Tile object for the given identifier.
        &#34;&#34;&#34;
        return _tile.Tile(self.mb, identifier=identifier)

    def tilemap_background(self):
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _background_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

        Returns
        -------
        `pyboy.botsupport.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;
        return _tilemap.TileMap(self.mb, &#34;BACKGROUND&#34;)

    def tilemap_window(self):
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _window_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

        Returns
        -------
        `pyboy.botsupport.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;
        return _tilemap.TileMap(self.mb, &#34;WINDOW&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyboy.botsupport.BotSupportManager.screen"><code class="name flex">
<span>def <span class="ident">screen</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this method to get a <code><a title="pyboy.botsupport.screen.Screen" href="screen.html#pyboy.botsupport.screen.Screen">Screen</a></code> object. This can be used to get the screen buffer in
a variety of formats.</p>
<p>It's also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
<code><a title="pyboy.botsupport.screen.Screen.tilemap_position" href="screen.html#pyboy.botsupport.screen.Screen.tilemap_position">Screen.tilemap_position()</a></code> for more information.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.botsupport.screen.Screen" href="screen.html#pyboy.botsupport.screen.Screen">Screen</a></code>:
A Screen object with helper functions for reading the screen buffer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def screen(self):
    &#34;&#34;&#34;
    Use this method to get a `pyboy.botsupport.screen.Screen` object. This can be used to get the screen buffer in
    a variety of formats.

    It&#39;s also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
    `pyboy.botsupport.screen.Screen.tilemap_position` for more information.

    Returns
    -------
    `pyboy.botsupport.screen.Screen`:
        A Screen object with helper functions for reading the screen buffer.
    &#34;&#34;&#34;
    return _screen.Screen(self.mb)</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.BotSupportManager.sprite"><code class="name flex">
<span>def <span class="ident">sprite</span></span>(<span>self, sprite_index)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides a <code><a title="pyboy.botsupport.sprite.Sprite" href="sprite.html#pyboy.botsupport.sprite.Sprite">Sprite</a></code> object, which makes the OAM data more presentable. The given index
corresponds to index of the sprite in the "Object Attribute Memory" (OAM).</p>
<p>The Game Boy supports 40 sprites in total. Read more details about it, in the <a href="http://bgb.bircd.org/pandocs.htm">Pan
Docs</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Sprite index from 0 to 39.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.botsupport.sprite.Sprite" href="sprite.html#pyboy.botsupport.sprite.Sprite">Sprite</a></code>:
Sprite corresponding to the given index.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sprite(self, sprite_index):
    &#34;&#34;&#34;
    Provides a `pyboy.botsupport.sprite.Sprite` object, which makes the OAM data more presentable. The given index
    corresponds to index of the sprite in the &#34;Object Attribute Memory&#34; (OAM).

    The Game Boy supports 40 sprites in total. Read more details about it, in the [Pan
    Docs](http://bgb.bircd.org/pandocs.htm).

    Args:
        index (int): Sprite index from 0 to 39.
    Returns
    -------
    `pyboy.botsupport.sprite.Sprite`:
        Sprite corresponding to the given index.
    &#34;&#34;&#34;
    return _sprite.Sprite(self.mb, sprite_index)</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.BotSupportManager.sprite_by_tile_identifier"><code class="name flex">
<span>def <span class="ident">sprite_by_tile_identifier</span></span>(<span>self, tile_identifiers, on_screen=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
<code><a title="pyboy.botsupport.BotSupportManager.sprite" href="#pyboy.botsupport.BotSupportManager.sprite">BotSupportManager.sprite()</a></code> function to get a <code><a title="pyboy.botsupport.sprite.Sprite" href="sprite.html#pyboy.botsupport.sprite.Sprite">Sprite</a></code> object.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; print(pyboy.botsupport_manager().sprite_by_tile_identifier([43, 123]))
[[0, 2, 4], []]
</code></pre>
<p>Meaning, that tile identifier <code>43</code> is found at the sprite indexes: 0, 2, and 4, while tile identifier
<code>123</code> was not found anywhere.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifiers</code></strong> :&ensp;<code>list</code></dt>
<dd>List of tile identifiers (int)</dd>
<dt><strong><code>on_screen</code></strong> :&ensp;<code>bool</code></dt>
<dd>Require that the matched sprite is on screen</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list:</code></dt>
<dd>list of sprite matches for every tile identifier in the input</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sprite_by_tile_identifier(self, tile_identifiers, on_screen=True):
    &#34;&#34;&#34;
    Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
    identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
    `pyboy.botsupport.BotSupportManager.sprite` function to get a `pyboy.botsupport.sprite.Sprite` object.

    Example:
    ```
    &gt;&gt;&gt; print(pyboy.botsupport_manager().sprite_by_tile_identifier([43, 123]))
    [[0, 2, 4], []]
    ```

    Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2, and 4, while tile identifier
    `123` was not found anywhere.

    Args:
        identifiers (list): List of tile identifiers (int)
        on_screen (bool): Require that the matched sprite is on screen

    Returns
    -------
    list:
        list of sprite matches for every tile identifier in the input
    &#34;&#34;&#34;

    matches = []
    for i in tile_identifiers:
        match = []
        for s in range(_constants.SPRITES):
            sprite = _sprite.Sprite(self.mb, s)
            for t in sprite.tiles:
                if t.tile_identifier == i and (not on_screen or (on_screen and sprite.on_screen)):
                    match.append(s)
        matches.append(match)
    return matches</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.BotSupportManager.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy can have 384 tiles loaded in memory at once. Use this method to get a
<code><a title="pyboy.botsupport.tile.Tile" href="tile.html#pyboy.botsupport.tile.Tile">Tile</a></code>-object for given identifier.</p>
<p>The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
the <code><a title="pyboy.botsupport.tile.Tile" href="tile.html#pyboy.botsupport.tile.Tile">Tile</a></code> object for more information.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.botsupport.tile.Tile" href="tile.html#pyboy.botsupport.tile.Tile">Tile</a></code>:
A Tile object for the given identifier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(self, identifier):
    &#34;&#34;&#34;
    The Game Boy can have 384 tiles loaded in memory at once. Use this method to get a
    `pyboy.botsupport.tile.Tile`-object for given identifier.

    The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
    the `pyboy.botsupport.tile.Tile` object for more information.

    Returns
    -------
    `pyboy.botsupport.tile.Tile`:
        A Tile object for the given identifier.
    &#34;&#34;&#34;
    return _tile.Tile(self.mb, identifier=identifier)</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.BotSupportManager.tilemap_background"><code class="name flex">
<span>def <span class="ident">tilemap_background</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
for the <em>background</em> tiles. The game chooses whether it wants to use the low or the high tilemap.</p>
<p>Read more details about it, in the <a href="http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps">Pan Docs</a>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.botsupport.tilemap.TileMap" href="tilemap.html#pyboy.botsupport.tilemap.TileMap">TileMap</a></code>:
A TileMap object for the tile map.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tilemap_background(self):
    &#34;&#34;&#34;
    The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
    for the _background_ tiles. The game chooses whether it wants to use the low or the high tilemap.

    Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

    Returns
    -------
    `pyboy.botsupport.tilemap.TileMap`:
        A TileMap object for the tile map.
    &#34;&#34;&#34;
    return _tilemap.TileMap(self.mb, &#34;BACKGROUND&#34;)</code></pre>
</details>
</dd>
<dt id="pyboy.botsupport.BotSupportManager.tilemap_window"><code class="name flex">
<span>def <span class="ident">tilemap_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
for the <em>window</em> tiles. The game chooses whether it wants to use the low or the high tilemap.</p>
<p>Read more details about it, in the <a href="http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps">Pan Docs</a>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="pyboy.botsupport.tilemap.TileMap" href="tilemap.html#pyboy.botsupport.tilemap.TileMap">TileMap</a></code>:
A TileMap object for the tile map.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tilemap_window(self):
    &#34;&#34;&#34;
    The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
    for the _window_ tiles. The game chooses whether it wants to use the low or the high tilemap.

    Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

    Returns
    -------
    `pyboy.botsupport.tilemap.TileMap`:
        A TileMap object for the tile map.
    &#34;&#34;&#34;
    return _tilemap.TileMap(self.mb, &#34;WINDOW&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyboy" href="../index.html">pyboy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyboy.botsupport.screen" href="screen.html">pyboy.botsupport.screen</a></code></li>
<li><code><a title="pyboy.botsupport.sprite" href="sprite.html">pyboy.botsupport.sprite</a></code></li>
<li><code><a title="pyboy.botsupport.tile" href="tile.html">pyboy.botsupport.tile</a></code></li>
<li><code><a title="pyboy.botsupport.tilemap" href="tilemap.html">pyboy.botsupport.tilemap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.botsupport.BotSupportManager" href="#pyboy.botsupport.BotSupportManager">BotSupportManager</a></code></h4>
<ul class="">
<li><code><a title="pyboy.botsupport.BotSupportManager.screen" href="#pyboy.botsupport.BotSupportManager.screen">screen</a></code></li>
<li><code><a title="pyboy.botsupport.BotSupportManager.sprite" href="#pyboy.botsupport.BotSupportManager.sprite">sprite</a></code></li>
<li><code><a title="pyboy.botsupport.BotSupportManager.sprite_by_tile_identifier" href="#pyboy.botsupport.BotSupportManager.sprite_by_tile_identifier">sprite_by_tile_identifier</a></code></li>
<li><code><a title="pyboy.botsupport.BotSupportManager.tile" href="#pyboy.botsupport.BotSupportManager.tile">tile</a></code></li>
<li><code><a title="pyboy.botsupport.BotSupportManager.tilemap_background" href="#pyboy.botsupport.BotSupportManager.tilemap_background">tilemap_background</a></code></li>
<li><code><a title="pyboy.botsupport.BotSupportManager.tilemap_window" href="#pyboy.botsupport.BotSupportManager.tilemap_window">tilemap_window</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>