<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyboy.api.tile API documentation</title>
<meta name="description" content="The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used both for
`pyboy.api.sprite.Sprite` and â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:0.8em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy.api.tile</code></h1>
</header>
<section id="section-intro">
<p>The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used both for
<code><a title="pyboy.api.sprite.Sprite" href="sprite.html#pyboy.api.sprite.Sprite">Sprite</a></code> and <code><a title="pyboy.api.tilemap.TileMap" href="tilemap.html#pyboy.api.tilemap.TileMap">TileMap</a></code>, when refering to graphics.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# License: See LICENSE.md file
# GitHub: https://github.com/Baekalfen/PyBoy
#
&#34;&#34;&#34;
The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used both for
`pyboy.api.sprite.Sprite` and `pyboy.api.tilemap.TileMap`, when refering to graphics.
&#34;&#34;&#34;

import numpy as np

import pyboy
from pyboy import utils

from .constants import LOW_TILEDATA, TILES, TILES_CGB, VRAM_OFFSET

logger = pyboy.logging.get_logger(__name__)

try:
    from PIL import Image
except ImportError:
    Image = None

try:
    from cython import compiled
    cythonmode = compiled
except ImportError:
    cythonmode = False


class Tile:
    def __init__(self, mb, identifier):
        &#34;&#34;&#34;
        The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used for
        `pyboy.PyBoy.get_tile`, `pyboy.api.sprite.Sprite` and `pyboy.api.tilemap.TileMap`, when refering to graphics.

        This class is not meant to be instantiated by developers reading this documentation, but it will be created
        internally and returned by `pyboy.api.sprite.Sprite.tiles` and
        `pyboy.api.tilemap.TileMap.tile`.

        The data of this class is static, apart from the image data, which is loaded from the Game Boy&#39;s memory when
        needed. Beware that the graphics for the tile can change between each call to `pyboy.PyBoy.tick`.
        &#34;&#34;&#34;
        self.mb = mb

        if self.mb.cgb:
            assert 0 &lt;= identifier &lt; TILES_CGB, &#34;Identifier out of range&#34;
        else:
            assert 0 &lt;= identifier &lt; TILES, &#34;Identifier out of range&#34;

        self.data_address = LOW_TILEDATA + (16 * (identifier%TILES))
        &#34;&#34;&#34;
        The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
        corresponding to the tile identifier. It is advised to use `pyboy.api.tile.Tile.image` or one of the
        other `image`-functions if you want to view the tile.

        You can read how the data is read in the
        [Pan Docs: VRAM Tile Data](https://gbdev.io/pandocs/Tile_Data.html).

        Returns
        -------
        int:
            address in VRAM where tile data starts
        &#34;&#34;&#34;

        if identifier &lt; TILES:
            self.vram_bank = 0
        else:
            self.vram_bank = 1

        self.tile_identifier = identifier
        &#34;&#34;&#34;
        The Game Boy has a slightly complicated indexing system for tiles. This identifier unifies the otherwise
        complicated indexing system on the Game Boy into a single range of 0-383 (both included) or 0-767 for Game Boy
        Color.

        Returns
        -------
        int:
            Unique identifier for the tile
        &#34;&#34;&#34;

        self.shape = (8, 8)
        &#34;&#34;&#34;
        Tiles are always 8x8 pixels.

        Returns
        -------
        (int, int):
            The width and height of the tile.
        &#34;&#34;&#34;

        self.raw_buffer_format = self.mb.lcd.renderer.color_format
        &#34;&#34;&#34;
        Returns the color format of the raw screen buffer.

        Returns
        -------
        str:
            Color format of the raw screen buffer. E.g. &#39;RGBA&#39;.
        &#34;&#34;&#34;

    def image(self):
        &#34;&#34;&#34;
        Use this function to get an `PIL.Image` object of the tile. The image is 8x8 pixels. The format or &#34;mode&#34; might change at any time.

        Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

        Example:
        ```python
        &gt;&gt;&gt; tile = pyboy.get_tile(1)
        &gt;&gt;&gt; tile.image().save(&#39;tile_1.png&#39;)

        ```

        Returns
        -------
        PIL.Image :
            Image of tile in 8x8 pixels and RGBA colors.
        &#34;&#34;&#34;
        if Image is None:
            logger.error(f&#34;{__name__}: Missing dependency \&#34;Pillow\&#34;.&#34;)
            return None

        if cythonmode:
            return Image.fromarray(self._image_data().base, mode=self.raw_buffer_format)
        else:
            return Image.frombytes(self.raw_buffer_format, (8, 8), self._image_data())

    def ndarray(self):
        &#34;&#34;&#34;
        Use this function to get an `numpy.ndarray` object of the tile. The array has a shape of (8, 8, 4)
        and each value is of `numpy.uint8`. The values corresponds to an image of 8x8 pixels with each sub-color
        in a separate cell. The format is given by `pyboy.api.tile.Tile.raw_buffer_format`.

        Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

        Example:
        ```python
        &gt;&gt;&gt; tile1 = pyboy.get_tile(1)
        &gt;&gt;&gt; tile1.ndarray()[:,:,0] # Upper part of &#34;P&#34;
        array([[255, 255, 255, 255, 255, 255, 255, 255],
               [255, 255, 255, 255, 255, 255, 255, 255],
               [255, 255, 255, 255, 255, 255, 255, 255],
               [255,   0,   0,   0,   0,   0, 255, 255],
               [255,   0,   0,   0,   0,   0,   0, 255],
               [255,   0,   0, 255, 255,   0,   0, 255],
               [255,   0,   0, 255, 255,   0,   0, 255],
               [255,   0,   0, 255, 255,   0,   0, 255]], dtype=uint8)
        &gt;&gt;&gt; tile2 = pyboy.get_tile(2)
        &gt;&gt;&gt; tile2.ndarray()[:,:,0] # Lower part of &#34;P&#34;
        array([[255,   0,   0,   0,   0,   0,   0, 255],
               [255,   0,   0,   0,   0,   0, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255, 255, 255, 255, 255, 255, 255, 255]], dtype=uint8)

        ```

        Returns
        -------
        numpy.ndarray :
            Array of shape (8, 8, 4) with data type of `numpy.uint8`.
        &#34;&#34;&#34;
        # The data is laid out as (X, red, green, blue), where X is currently always zero, but this is not guarenteed
        # across versions of PyBoy.
        return np.asarray(self._image_data()).view(dtype=np.uint8).reshape(8, 8, 4)

    def _image_data(self):
        &#34;&#34;&#34;
        Use this function to get the raw tile data. The data is a `memoryview` corresponding to 8x8 pixels in RGBA
        colors.

        Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

        Returns
        -------
        memoryview :
            Image data of tile in 8x8 pixels and RGB colors.
        &#34;&#34;&#34;
        self.data = np.zeros((8, 8), dtype=np.uint32)
        for k in range(0, 16, 2): # 2 bytes for each line
            if self.vram_bank == 0:
                byte1 = self.mb.lcd.VRAM0[self.data_address + k - VRAM_OFFSET]
                byte2 = self.mb.lcd.VRAM0[self.data_address + k + 1 - VRAM_OFFSET]
            else:
                byte1 = self.mb.lcd.VRAM1[self.data_address + k - VRAM_OFFSET]
                byte2 = self.mb.lcd.VRAM1[self.data_address + k + 1 - VRAM_OFFSET]

            for x in range(8):
                colorcode = utils.color_code(byte1, byte2, 7 - x)
                self.data[k // 2][x] = self.mb.lcd.BGP.getcolor(colorcode)
        return self.data

    def __eq__(self, other):
        return self.data_address == other.data_address and self.vram_bank == other.vram_bank

    def __repr__(self):
        return f&#34;Tile: {self.tile_identifier}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.api.tile.Tile"><code class="flex name class">
<span>class <span class="ident">Tile</span></span>
<span>(</span><span>mb, identifier)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used for
<code><a title="pyboy.PyBoy.get_tile" href="../index.html#pyboy.PyBoy.get_tile">PyBoy.get_tile()</a></code>, <code><a title="pyboy.api.sprite.Sprite" href="sprite.html#pyboy.api.sprite.Sprite">Sprite</a></code> and <code><a title="pyboy.api.tilemap.TileMap" href="tilemap.html#pyboy.api.tilemap.TileMap">TileMap</a></code>, when refering to graphics.</p>
<p>This class is not meant to be instantiated by developers reading this documentation, but it will be created
internally and returned by <code><a title="pyboy.api.sprite.Sprite.tiles" href="sprite.html#pyboy.api.sprite.Sprite.tiles">Sprite.tiles</a></code> and
<code><a title="pyboy.api.tilemap.TileMap.tile" href="tilemap.html#pyboy.api.tilemap.TileMap.tile">TileMap.tile()</a></code>.</p>
<p>The data of this class is static, apart from the image data, which is loaded from the Game Boy's memory when
needed. Beware that the graphics for the tile can change between each call to <code><a title="pyboy.PyBoy.tick" href="../index.html#pyboy.PyBoy.tick">PyBoy.tick()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tile:
    def __init__(self, mb, identifier):
        &#34;&#34;&#34;
        The Game Boy uses tiles as the building block for all graphics on the screen. This base-class is used for
        `pyboy.PyBoy.get_tile`, `pyboy.api.sprite.Sprite` and `pyboy.api.tilemap.TileMap`, when refering to graphics.

        This class is not meant to be instantiated by developers reading this documentation, but it will be created
        internally and returned by `pyboy.api.sprite.Sprite.tiles` and
        `pyboy.api.tilemap.TileMap.tile`.

        The data of this class is static, apart from the image data, which is loaded from the Game Boy&#39;s memory when
        needed. Beware that the graphics for the tile can change between each call to `pyboy.PyBoy.tick`.
        &#34;&#34;&#34;
        self.mb = mb

        if self.mb.cgb:
            assert 0 &lt;= identifier &lt; TILES_CGB, &#34;Identifier out of range&#34;
        else:
            assert 0 &lt;= identifier &lt; TILES, &#34;Identifier out of range&#34;

        self.data_address = LOW_TILEDATA + (16 * (identifier%TILES))
        &#34;&#34;&#34;
        The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
        corresponding to the tile identifier. It is advised to use `pyboy.api.tile.Tile.image` or one of the
        other `image`-functions if you want to view the tile.

        You can read how the data is read in the
        [Pan Docs: VRAM Tile Data](https://gbdev.io/pandocs/Tile_Data.html).

        Returns
        -------
        int:
            address in VRAM where tile data starts
        &#34;&#34;&#34;

        if identifier &lt; TILES:
            self.vram_bank = 0
        else:
            self.vram_bank = 1

        self.tile_identifier = identifier
        &#34;&#34;&#34;
        The Game Boy has a slightly complicated indexing system for tiles. This identifier unifies the otherwise
        complicated indexing system on the Game Boy into a single range of 0-383 (both included) or 0-767 for Game Boy
        Color.

        Returns
        -------
        int:
            Unique identifier for the tile
        &#34;&#34;&#34;

        self.shape = (8, 8)
        &#34;&#34;&#34;
        Tiles are always 8x8 pixels.

        Returns
        -------
        (int, int):
            The width and height of the tile.
        &#34;&#34;&#34;

        self.raw_buffer_format = self.mb.lcd.renderer.color_format
        &#34;&#34;&#34;
        Returns the color format of the raw screen buffer.

        Returns
        -------
        str:
            Color format of the raw screen buffer. E.g. &#39;RGBA&#39;.
        &#34;&#34;&#34;

    def image(self):
        &#34;&#34;&#34;
        Use this function to get an `PIL.Image` object of the tile. The image is 8x8 pixels. The format or &#34;mode&#34; might change at any time.

        Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

        Example:
        ```python
        &gt;&gt;&gt; tile = pyboy.get_tile(1)
        &gt;&gt;&gt; tile.image().save(&#39;tile_1.png&#39;)

        ```

        Returns
        -------
        PIL.Image :
            Image of tile in 8x8 pixels and RGBA colors.
        &#34;&#34;&#34;
        if Image is None:
            logger.error(f&#34;{__name__}: Missing dependency \&#34;Pillow\&#34;.&#34;)
            return None

        if cythonmode:
            return Image.fromarray(self._image_data().base, mode=self.raw_buffer_format)
        else:
            return Image.frombytes(self.raw_buffer_format, (8, 8), self._image_data())

    def ndarray(self):
        &#34;&#34;&#34;
        Use this function to get an `numpy.ndarray` object of the tile. The array has a shape of (8, 8, 4)
        and each value is of `numpy.uint8`. The values corresponds to an image of 8x8 pixels with each sub-color
        in a separate cell. The format is given by `pyboy.api.tile.Tile.raw_buffer_format`.

        Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

        Example:
        ```python
        &gt;&gt;&gt; tile1 = pyboy.get_tile(1)
        &gt;&gt;&gt; tile1.ndarray()[:,:,0] # Upper part of &#34;P&#34;
        array([[255, 255, 255, 255, 255, 255, 255, 255],
               [255, 255, 255, 255, 255, 255, 255, 255],
               [255, 255, 255, 255, 255, 255, 255, 255],
               [255,   0,   0,   0,   0,   0, 255, 255],
               [255,   0,   0,   0,   0,   0,   0, 255],
               [255,   0,   0, 255, 255,   0,   0, 255],
               [255,   0,   0, 255, 255,   0,   0, 255],
               [255,   0,   0, 255, 255,   0,   0, 255]], dtype=uint8)
        &gt;&gt;&gt; tile2 = pyboy.get_tile(2)
        &gt;&gt;&gt; tile2.ndarray()[:,:,0] # Lower part of &#34;P&#34;
        array([[255,   0,   0,   0,   0,   0,   0, 255],
               [255,   0,   0,   0,   0,   0, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255,   0,   0, 255, 255, 255, 255, 255],
               [255, 255, 255, 255, 255, 255, 255, 255]], dtype=uint8)

        ```

        Returns
        -------
        numpy.ndarray :
            Array of shape (8, 8, 4) with data type of `numpy.uint8`.
        &#34;&#34;&#34;
        # The data is laid out as (X, red, green, blue), where X is currently always zero, but this is not guarenteed
        # across versions of PyBoy.
        return np.asarray(self._image_data()).view(dtype=np.uint8).reshape(8, 8, 4)

    def _image_data(self):
        &#34;&#34;&#34;
        Use this function to get the raw tile data. The data is a `memoryview` corresponding to 8x8 pixels in RGBA
        colors.

        Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

        Returns
        -------
        memoryview :
            Image data of tile in 8x8 pixels and RGB colors.
        &#34;&#34;&#34;
        self.data = np.zeros((8, 8), dtype=np.uint32)
        for k in range(0, 16, 2): # 2 bytes for each line
            if self.vram_bank == 0:
                byte1 = self.mb.lcd.VRAM0[self.data_address + k - VRAM_OFFSET]
                byte2 = self.mb.lcd.VRAM0[self.data_address + k + 1 - VRAM_OFFSET]
            else:
                byte1 = self.mb.lcd.VRAM1[self.data_address + k - VRAM_OFFSET]
                byte2 = self.mb.lcd.VRAM1[self.data_address + k + 1 - VRAM_OFFSET]

            for x in range(8):
                colorcode = utils.color_code(byte1, byte2, 7 - x)
                self.data[k // 2][x] = self.mb.lcd.BGP.getcolor(colorcode)
        return self.data

    def __eq__(self, other):
        return self.data_address == other.data_address and self.vram_bank == other.vram_bank

    def __repr__(self):
        return f&#34;Tile: {self.tile_identifier}&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyboy.api.tile.Tile.data_address"><code class="name">var <span class="ident">data_address</span></code></dt>
<dd>
<section class="desc"><p>The tile data is defined in a specific area of the Game Boy. This function returns the address of the tile data
corresponding to the tile identifier. It is advised to use <code><a title="pyboy.api.tile.Tile.image" href="#pyboy.api.tile.Tile.image">Tile.image()</a></code> or one of the
other <code>image</code>-functions if you want to view the tile.</p>
<p>You can read how the data is read in the
<a href="https://gbdev.io/pandocs/Tile_Data.html">Pan Docs: VRAM Tile Data</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>address in VRAM where tile data starts</dd>
</dl></section>
</dd>
<dt id="pyboy.api.tile.Tile.tile_identifier"><code class="name">var <span class="ident">tile_identifier</span></code></dt>
<dd>
<section class="desc"><p>The Game Boy has a slightly complicated indexing system for tiles. This identifier unifies the otherwise
complicated indexing system on the Game Boy into a single range of 0-383 (both included) or 0-767 for Game Boy
Color.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>Unique identifier for the tile</dd>
</dl></section>
</dd>
<dt id="pyboy.api.tile.Tile.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Tiles are always 8x8 pixels.</p>
<h2 id="returns">Returns</h2>
<p>(int, int):
The width and height of the tile.</p></section>
</dd>
<dt id="pyboy.api.tile.Tile.raw_buffer_format"><code class="name">var <span class="ident">raw_buffer_format</span></code></dt>
<dd>
<section class="desc"><p>Returns the color format of the raw screen buffer.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str:</code></dt>
<dd>Color format of the raw screen buffer. E.g. 'RGBA'.</dd>
</dl></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyboy.api.tile.Tile.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this function to get an <code>PIL.Image</code> object of the tile. The image is 8x8 pixels. The format or "mode" might change at any time.</p>
<p>Be aware, that the graphics for this tile can change between each call to <code><a title="pyboy.PyBoy.tick" href="../index.html#pyboy.PyBoy.tick">PyBoy.tick()</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; tile = pyboy.get_tile(1)
&gt;&gt;&gt; tile.image().save('tile_1.png')

</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image :</code></dt>
<dd>Image of tile in 8x8 pixels and RGBA colors.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image(self):
    &#34;&#34;&#34;
    Use this function to get an `PIL.Image` object of the tile. The image is 8x8 pixels. The format or &#34;mode&#34; might change at any time.

    Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

    Example:
    ```python
    &gt;&gt;&gt; tile = pyboy.get_tile(1)
    &gt;&gt;&gt; tile.image().save(&#39;tile_1.png&#39;)

    ```

    Returns
    -------
    PIL.Image :
        Image of tile in 8x8 pixels and RGBA colors.
    &#34;&#34;&#34;
    if Image is None:
        logger.error(f&#34;{__name__}: Missing dependency \&#34;Pillow\&#34;.&#34;)
        return None

    if cythonmode:
        return Image.fromarray(self._image_data().base, mode=self.raw_buffer_format)
    else:
        return Image.frombytes(self.raw_buffer_format, (8, 8), self._image_data())</code></pre>
</details>
</dd>
<dt id="pyboy.api.tile.Tile.ndarray"><code class="name flex">
<span>def <span class="ident">ndarray</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this function to get an <code>numpy.ndarray</code> object of the tile. The array has a shape of (8, 8, 4)
and each value is of <code>numpy.uint8</code>. The values corresponds to an image of 8x8 pixels with each sub-color
in a separate cell. The format is given by <code><a title="pyboy.api.tile.Tile.raw_buffer_format" href="#pyboy.api.tile.Tile.raw_buffer_format">Tile.raw_buffer_format</a></code>.</p>
<p>Be aware, that the graphics for this tile can change between each call to <code><a title="pyboy.PyBoy.tick" href="../index.html#pyboy.PyBoy.tick">PyBoy.tick()</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; tile1 = pyboy.get_tile(1)
&gt;&gt;&gt; tile1.ndarray()[:,:,0] # Upper part of &quot;P&quot;
array([[255, 255, 255, 255, 255, 255, 255, 255],
       [255, 255, 255, 255, 255, 255, 255, 255],
       [255, 255, 255, 255, 255, 255, 255, 255],
       [255,   0,   0,   0,   0,   0, 255, 255],
       [255,   0,   0,   0,   0,   0,   0, 255],
       [255,   0,   0, 255, 255,   0,   0, 255],
       [255,   0,   0, 255, 255,   0,   0, 255],
       [255,   0,   0, 255, 255,   0,   0, 255]], dtype=uint8)
&gt;&gt;&gt; tile2 = pyboy.get_tile(2)
&gt;&gt;&gt; tile2.ndarray()[:,:,0] # Lower part of &quot;P&quot;
array([[255,   0,   0,   0,   0,   0,   0, 255],
       [255,   0,   0,   0,   0,   0, 255, 255],
       [255,   0,   0, 255, 255, 255, 255, 255],
       [255,   0,   0, 255, 255, 255, 255, 255],
       [255,   0,   0, 255, 255, 255, 255, 255],
       [255,   0,   0, 255, 255, 255, 255, 255],
       [255,   0,   0, 255, 255, 255, 255, 255],
       [255, 255, 255, 255, 255, 255, 255, 255]], dtype=uint8)

</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray :</code></dt>
<dd>Array of shape (8, 8, 4) with data type of <code>numpy.uint8</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ndarray(self):
    &#34;&#34;&#34;
    Use this function to get an `numpy.ndarray` object of the tile. The array has a shape of (8, 8, 4)
    and each value is of `numpy.uint8`. The values corresponds to an image of 8x8 pixels with each sub-color
    in a separate cell. The format is given by `pyboy.api.tile.Tile.raw_buffer_format`.

    Be aware, that the graphics for this tile can change between each call to `pyboy.PyBoy.tick`.

    Example:
    ```python
    &gt;&gt;&gt; tile1 = pyboy.get_tile(1)
    &gt;&gt;&gt; tile1.ndarray()[:,:,0] # Upper part of &#34;P&#34;
    array([[255, 255, 255, 255, 255, 255, 255, 255],
           [255, 255, 255, 255, 255, 255, 255, 255],
           [255, 255, 255, 255, 255, 255, 255, 255],
           [255,   0,   0,   0,   0,   0, 255, 255],
           [255,   0,   0,   0,   0,   0,   0, 255],
           [255,   0,   0, 255, 255,   0,   0, 255],
           [255,   0,   0, 255, 255,   0,   0, 255],
           [255,   0,   0, 255, 255,   0,   0, 255]], dtype=uint8)
    &gt;&gt;&gt; tile2 = pyboy.get_tile(2)
    &gt;&gt;&gt; tile2.ndarray()[:,:,0] # Lower part of &#34;P&#34;
    array([[255,   0,   0,   0,   0,   0,   0, 255],
           [255,   0,   0,   0,   0,   0, 255, 255],
           [255,   0,   0, 255, 255, 255, 255, 255],
           [255,   0,   0, 255, 255, 255, 255, 255],
           [255,   0,   0, 255, 255, 255, 255, 255],
           [255,   0,   0, 255, 255, 255, 255, 255],
           [255,   0,   0, 255, 255, 255, 255, 255],
           [255, 255, 255, 255, 255, 255, 255, 255]], dtype=uint8)

    ```

    Returns
    -------
    numpy.ndarray :
        Array of shape (8, 8, 4) with data type of `numpy.uint8`.
    &#34;&#34;&#34;
    # The data is laid out as (X, red, green, blue), where X is currently always zero, but this is not guarenteed
    # across versions of PyBoy.
    return np.asarray(self._image_data()).view(dtype=np.uint8).reshape(8, 8, 4)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyboy.api" href="index.html">pyboy.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.api.tile.Tile" href="#pyboy.api.tile.Tile">Tile</a></code></h4>
<ul class="two-column">
<li><code><a title="pyboy.api.tile.Tile.image" href="#pyboy.api.tile.Tile.image">image</a></code></li>
<li><code><a title="pyboy.api.tile.Tile.ndarray" href="#pyboy.api.tile.Tile.ndarray">ndarray</a></code></li>
<li><code><a title="pyboy.api.tile.Tile.data_address" href="#pyboy.api.tile.Tile.data_address">data_address</a></code></li>
<li><code><a title="pyboy.api.tile.Tile.tile_identifier" href="#pyboy.api.tile.Tile.tile_identifier">tile_identifier</a></code></li>
<li><code><a title="pyboy.api.tile.Tile.shape" href="#pyboy.api.tile.Tile.shape">shape</a></code></li>
<li><code><a title="pyboy.api.tile.Tile.raw_buffer_format" href="#pyboy.api.tile.Tile.raw_buffer_format">raw_buffer_format</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>